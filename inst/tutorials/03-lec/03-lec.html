<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<meta name="progressive" content="true" />
<meta name="allow-skip" content="true" />
<meta name="learnr-version-prerender" content="0.11.1" />

<title>Lecture: Bayesian Fundamentals</title>

<!-- header-includes START -->
<!-- HEAD_CONTENT -->
<!-- header-includes END -->
<!-- HEAD_CONTENT -->

<!-- highlightjs -->
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>


<!-- taken from https://github.com/rstudio/rmarkdown/blob/de8a9c38618903627ca509f5401d50a0876079f7/inst/rmd/h/default.html#L293-L343 -->
<!-- tabsets -->
<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>
<!-- end tabsets -->

<link rel="stylesheet" href="css/learnr-theme.css" type="text/css" />

</head>

<body>
<a class='sr-only sr-only-focusable visually-hidden-focusable' href='#learnr-tutorial-content'>Skip to Tutorial Content</a>



<div class="pageContent band">
<main class="bandContent page">

<article class="topics" id="learnr-tutorial-content">

<div id="section-bayesian-fundamentals" class="section level2">
<h2>Bayesian Fundamentals</h2>
<div id="section-the-punchline" class="section level3">
<h3>The punchline</h3>
<blockquote>
<p><sub> In the Bayesian world the unobserved quantities are assigned
distributional properties and, therefore, become random variables in the
analysis. </sub> <br></p>
<p><sub> These distributions come in two basic flavors. If the
distribution of the unknown quantity is not conditioned on fixed data,
it is called prior distribution because it describes knowledge prior to
seeing data. </sub> <br></p>
<p><sub> Alternatively, if the distribution is conditioned on data that
we observe, it is clearly updated from the unconditioned state and,
therefore, more informed. This distribution is called posterior
distribution. […] </sub> <br></p>
<p><sub> The punchline is this: All likelihood-based models are Bayesian
models in which the prior distribution is an appropriately selected
uniform prior, and as the size of the data gets large they are identical
given any finite appropriate prior. So such empirical researchers are
really Bayesian; they just do not know it yet. </sub></p>
</blockquote>
<div style="text-align: right">
<p><sub><sup> <a
href="https://academic.oup.com/jpart/article/23/2/457/1003493">Gill, J.,
&amp; Witko, C. (2013). Bayesian analytical methods: A methodological
prescription for public administration. Journal of Public Administration
Research and Theory, 23(2), 457–494.</a> </sub></sup></p>
</div>
</div>
<div id="section-likelihood-function" class="section level3">
<h3>Likelihood function</h3>
<ul>
<li>Specification of a pdf or pmf: <span
class="math inline">\(p(\mathbf{y}|\theta)\)</span>.</li>
<li>Also called the data generating process (or the generative model)
for <span class="math inline">\(y\)</span>.</li>
<li>Logical inversion: “Which unknown <span
class="math inline">\(\theta\)</span> most likely produces the known
<span class="math inline">\(\mathbf{y}\)</span>?” <span
class="math inline">\(\rightarrow\)</span> <span
class="math inline">\(L(\theta | \mathbf{y})\)</span>.</li>
<li>The notational distinction between <span
class="math inline">\(p(\mathbf{y}|\theta)\)</span> and <span
class="math inline">\(L(\theta | \mathbf{y})\)</span> is purely
conceptual. <span class="math inline">\(p(\mathbf{y}|\theta) = L(\theta
| \mathbf{y})\)</span>.</li>
<li>We will use <span
class="math inline">\(p(\mathbf{y}|\theta)\)</span>.</li>
<li>Note that the likelihood function multiplies densities across
<em>all</em> observations; e.g., a normal likelihood function is given
by:</li>
</ul>
<p><span class="math display">\[p(\mathbf{y}|\mu, \sigma) =
\prod_{i=1}^{N} \frac{1}{\sigma \sqrt{2 \pi}} \exp\left(- 0.5 \left(
(y_i - \mu_i)^2 / \sigma \right) \right)\]</span></p>
<ul>
<li>This is what we mean mathematically when we use the shorthand
<ul>
<li><span class="math inline">\(\mathbf{y} \sim \text{N}(\mu,
\sigma)\)</span> or</li>
<li><span class="math inline">\(y_i \sim \text{N}(\mu_i, \sigma) \text{
for all } i=1,...N\)</span>.</li>
</ul></li>
</ul>
</div>
<div id="section-prior-distribution" class="section level3">
<h3>Prior distribution</h3>
<ul>
<li>A distributional characterization of our belief about an unknown
quantity (i.e., a parameter) prior to seeing the data: <span
class="math inline">\(p(\theta)\)</span></li>
<li>This includes statements about <em>family</em>, <em>support</em>,
and <em>density</em>.
<ul>
<li><em>Family</em>: A pdf (continuous parameters) or pmf (discrete
parameters) that can plausibly generate the parameter values.</li>
<li><em>Support</em>: Some parameters have constrained support:
Probability parameters must be inside <span class="math inline">\([0,
1]\)</span>; variance parameters must be <span
class="math inline">\(\geq 0\)</span>.</li>
<li><em>Density</em>: A distributional characterization which values of
the parameter we think are more or less likely to observe.</li>
</ul></li>
<li>The prior distribution can be
<ul>
<li>flat (i.e., uniformly distributed over the supported range – often
improper)</li>
<li>purposefully very vague, and thus, rather uninformative</li>
<li>weakly informative</li>
<li>specific and substantively informed (e.g., by previous research or
expert assessment)</li>
</ul></li>
</ul>
</div>
<div id="section-posterior-distribution" class="section level3">
<h3>Posterior distribution</h3>
<ul>
<li>Updating our distributional belief about <span
class="math inline">\(\theta\)</span> given the data, <span
class="math inline">\(\mathbf{y}\)</span>: <span
class="math inline">\(p(\theta | \mathbf{y})\)</span></li>
<li>Follows the proportional version of <a
href="https://en.wikipedia.org/wiki/Bayes%27_theorem">Bayes’ Law</a>:
<span class="math inline">\(p(\theta | \mathbf{y}) \propto p(\theta)
\times p(\mathbf{y}|\theta)\)</span></li>
<li>Yields a weighthed combination of likelihood and prior</li>
<li>The prior pulls the posterior density toward the center of gravity
of the prior distribution</li>
<li>As the data grows large, the likelihood becomes more influential:
<ul>
<li>one factor for <span class="math inline">\(p(\theta)\)</span>, <span
class="math inline">\(N\)</span> factors for <span
class="math inline">\(p(y_i|\theta_i)\)</span></li>
<li>we will see this analytically and using simulations later on</li>
</ul></li>
</ul>
</div>
</div>
<div id="section-coin-flip-experiment" class="section level2">
<h2>Coin flip experiment</h2>
<div id="section-the-experiment" class="section level3">
<h3>The experiment</h3>
<p>Suppose we flip a coin up to <span class="math inline">\(N\)</span>
times:</p>
<ul>
<li>The fairness of a coin can be expressed through a <em>probability
parameter</em>, <span class="math inline">\(\pi\)</span>, that governs
the probability that a coin flip produces heads (1) has opposed to tails
(0)</li>
<li>We start out with the belief that the coin is fair – that is, we
consider it more probable that the coin is fair (<span
class="math inline">\(\pi \approx 0.5\)</span>) and less probable that
it systematically over-produces either heads or tails</li>
<li>Unbeknownst to us, the coin is far from fair – it is 4 times as
likely to produce heads as it is to produce tails (that is, <span
class="math inline">\(\pi=0.8\)</span>)</li>
<li>We slowly learn about this in the process of flipping the coin and
keeping score of the number of flips <span
class="math inline">\(n\)</span> and the number of heads <span
class="math inline">\(k\)</span>…</li>
</ul>
</div>
<div id="section-analytical-form-prior-distribution"
class="section level3">
<h3>Analytical form: Prior distribution</h3>
<ul>
<li>The <em>beta distribution</em> is a suitable candidate for
characterizing our prior beliefs: <span class="math inline">\(\pi \sim
\text{beta}(a,b)\)</span></li>
<li>Characterized by two shape parameters, <span
class="math inline">\(a\)</span> and <span
class="math inline">\(b\)</span></li>
<li><span class="math inline">\(a\)</span> and <span
class="math inline">\(b\)</span> are <em>hyperparameters</em>: Known (or
chosen) parameters that characterize a prior distribution.</li>
<li>Constrained support: <span class="math inline">\(\pi \in [0,
1]\)</span></li>
<li>pdf: <span class="math inline">\(p(\pi) = \frac{\pi^{a-1} (1-
\pi)^{b-1}}{\text{B}(a, b)}\)</span></li>
</ul>
<p><img src="03-lec_files/figure-html/beta-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
<div id="section-analytical-form-likelihood" class="section level3">
<h3>Analytical form: Likelihood</h3>
<ul>
<li>Flipping one and the same coin <span
class="math inline">\(n\)</span> times is a series of Bernoulli
trials</li>
<li>The <em>binomial distribution</em> describes the corresponding data
generating process: <span class="math inline">\(k \sim
\text{Binomial}(n, \pi)\)</span></li>
<li>pmf: <span class="math inline">\(p(k|n, \pi) = {n \choose k} \pi^k
(1-\pi)^{(n-k)}\)</span></li>
</ul>
</div>
<div id="section-analytical-form-posterior-distribution"
class="section level3">
<h3>Analytical form: Posterior distribution</h3>
<p>Remember: <span class="math display">\[p(\theta | \mathbf{y}) \propto
p(\theta) \times p(\mathbf{y}|\theta)\]</span></p>
<p>So what does this mean in the present example?</p>
<p><span class="math display">\[\begin{split}p(\pi|n,k) &amp; \propto
p(\pi) \times p(k|n, \pi) \\
p(\pi|n,k) &amp; \propto \frac{\pi^{a-1} (1- \pi)^{b-1}}{\text{B}(a, b)}
\times {n \choose k} \pi^k (1-\pi)^{(n-k)}\end{split}\]</span></p>
<p>Note that since we use the proportional version of Bayes’ Law (i.e.,
we do not stipulate exact equality), we can drop any constant terms that
do not involve our parameter of interest, <span
class="math inline">\(\pi\)</span>:</p>
<p><span class="math display">\[\begin{split}p(\pi|n,k) &amp; \propto
\pi^{a-1} (1- \pi)^{b-1} \times \pi^k
(1-\pi)^{(n-k)}\end{split}\]</span> The rest, then, is easy: Following
the rules of exponentiation, we add exponents for identical bases. This
gives us our posterior distribution for <span
class="math inline">\(\pi\)</span>:</p>
<p><span class="math display">\[\begin{split}p(\pi|n,k) &amp; \propto
\pi^{a+k-1} (1- \pi)^{b+n-k-1}\end{split}\]</span> As you see, our
posterior has the exact same form as our prior. It is a beta
distribution with updated parameters</p>
<ul>
<li><span class="math inline">\(a^{\prime} = a+k-1\)</span></li>
<li><span class="math inline">\(b^{\prime} = b+n-k-1\)</span></li>
</ul>
<p>This property is called <em>conjugacy</em>: Prior and posterior are
of the same family.</p>
<p>Now, take a moment to think about our analytical solution for the
updated parameter:</p>
<ul>
<li>What does it take for the data to dominate the prior?</li>
<li>What if the prior is weak (e.g., <span class="math inline">\(\pi
\sim \text{beta}(1,1)\)</span>)?</li>
<li>What if the prior is strong (e.g., <span class="math inline">\(\pi
\sim \text{beta}(100,100)\)</span>)?</li>
</ul>
</div>
<div id="section-simulation" class="section level3">
<h3>Simulation</h3>
<div id="section-prior-distribution-1" class="section level4">
<h4>Prior distribution</h4>
<details>
<summary>
Code: Defining and plotting the prior distribution
</summary>
<pre class="r"><code>len_pi &lt;- 1001L                      ### number of candidate values for pi
pi &lt;- seq(0, 1, length.out = len_pi) ### candidate values for pi
a &lt;- b &lt;- 5                          ### hyperparameters
prior &lt;- dbeta(pi, a, b)             ### prior distribution

## Plot
plot(                                ### set up empty plot, specify labels
  pi, prior,
  type = &#39;n&#39;,
  xlab = &quot;Density&quot;,
  ylab = expression(paste(&quot;Prior Distribution for &quot;, pi))
)
polygon(                             ### draw density distribution
  c(rep(0, length(pi)), pi),
  c(prior, rev(prior)),
  col = adjustcolor(&#39;red&#39;, alpha.f = .4),
  border = NA
)
abline(                              ### add vertical at pi = 0.5 
  v = .5,
  col = &#39;white&#39;
)</code></pre>
</details>
<p><img src="03-lec_files/figure-html/coin-sim0-print-1.png" width="75%" style="display: block; margin: auto;" /></p>
</div>
<div id="section-posterior-distribution-1" class="section level4">
<h4>Posterior distribution</h4>
<details>
<summary>
Code: Simulating the experiment
</summary>
<pre class="r"><code>set.seed(20210329)                   ### set seed for replicability
len_pi &lt;- 1001L                      ### number of candidate values for pi
pi &lt;- seq(0, 1, length.out = len_pi) ### candidate values for pi
a &lt;- b &lt;- 5                          ### hyperparameters
n &lt;- 300                             ### num. of coin flips
pi_true &lt;- .8                        ### true parameter
data &lt;- rbinom(n, 1, pi_true)        ### n coin flips
posterior &lt;- matrix(NA, 3L, n)       ### matrix container for posterior

for (i in seq_len(n)) {    
  current_sequence &lt;- data[1:i]      ### sequence up until ith draw
  k &lt;- sum(current_sequence)         ### number of heads in current sequence
  
  ##### Updating
  a_prime &lt;- a + k               
  b_prime &lt;- b + i - k
  
  ### Analytical means and credible intervals
  posterior[1, i] &lt;- a_prime / (a_prime + b_prime)
  posterior[2, i] &lt;- qbeta(0.025, a_prime, b_prime)
  posterior[3, i] &lt;- qbeta(0.975, a_prime, b_prime)
}

## Plot
plot(                                ### set up empty plot with labels
  1:n, 1:n,
  type = &#39;n&#39;,
  xlab = &quot;Number of Coin Flips&quot;,
  ylab = expression(paste(&quot;Posterior Means of &quot;,
                          pi,
                          sep = &quot; &quot;)), 
  ylim = c(0, 1),
  xlim = c(1, n)
)
abline(                              ### reference line for the true pi
  h = c(.5, .8),
  col = &quot;gray80&quot;
)
rect(-.5, qbeta(0.025, 5, 5),        ### prior mean + interval at i = 0
     0.5, qbeta(0.975, 5, 5),
     col = adjustcolor(&#39;red&#39;, .4),
     border = adjustcolor(&#39;red&#39;, .2))
segments(-.5, .5,
         0.5, .5,
         col = adjustcolor(&#39;red&#39;, .9),
         lwd = 1.5)
polygon(                             ### posterior means + intervals
  c(seq_len(n), rev(seq_len(n))),
  c(posterior[2, ], rev(posterior[3, ])),
  col = adjustcolor(&#39;blue&#39;, .4),
  border = adjustcolor(&#39;blue&#39;, .2)
)
lines(
  seq_len(n),
  posterior[1, ],
  col = adjustcolor(&#39;blue&#39;, .9),
  lwd = 1.5
)</code></pre>
</details>
<p><img src="03-lec_files/figure-html/coin-sim2-1.png" width="75%" style="display: block; margin: auto;" /></p>
<p><em>Note:</em> After 300 coin flips, we have observed 241 heads,
which is a proportion of 0.803. The posterior median is 0.794; the 95%
credible interval is [0.747, 0.837].</p>
</div>
</div>
</div>
<div id="section-mcmc-algorithms" class="section level2">
<h2>MCMC algorithms</h2>
<div id="section-analytical-classical-bayesian-inference"
class="section level3">
<h3>Analytical (classical) Bayesian inference</h3>
<ul>
<li>As you may have noticed: Our coin flip example did <em>not</em>
involve <em>any</em> numerical estimation algorithms.</li>
<li>We simply observed the data, applied Bayes’ Law, and analytically
updated our parameters.</li>
<li>This allowed us to retrieve a distributional characterization of our
parameter of interest at each iteration of the coin flip series.</li>
<li>The reasons why we could do this with ease is that this simple
Binomial problem involved a single parameter <span
class="math inline">\(\pi\)</span>; i.e, we were dealing with a
uni-dimensional <em>parameter space</em>.</li>
</ul>
</div>
<div id="section-the-limits-of-analytical-bayesian-inference"
class="section level3">
<h3>The limits of analytical Bayesian inference</h3>
<ul>
<li>Even in only slightly more intricate applications, Bayesian
inference involves finding a <em>joint</em> posterior for <em>all</em>
parameters in a model, i.e., finding a <em>multi-dimensional</em>
parameter space.</li>
<li>Inference on single parameters from a joint multi-dimensional
parameter space requires that we retrieve the marginal posterior
distribution from the joint posterior distribution.</li>
<li>Marginalizing the joint multidimensional posterior distribution
w.r.t. to a given a parameter gives the posterior distribution for that
parameter. This requires <em>integrating</em> out all other
parameters.</li>
<li>For instance, when our joint posterior in a three-dimensional
parameter space is <span class="math inline">\(p(\alpha,\beta,
\gamma)\)</span>, we need to obtain each marginal posterior akin to
<span class="math inline">\(p(\alpha) = \int_{\beta} \int_{\gamma}
p(\alpha,\beta, \gamma) d\beta d\gamma\)</span></li>
<li>For complex multi-dimensional posterior distributions, finding
analytical solutions through integration becomes cumbersome, if not
outright impossible.</li>
</ul>
</div>
<div id="section-numerical-approximation-via-mcmc"
class="section level3">
<h3>Numerical approximation via MCMC</h3>
<p>That’s where numerical approximation through Markov Chain Monte Carlo
(MCMC) algorithms comes in:</p>
<ul>
<li>MCMC are iterative computational processes that explore and describe
a posterior distribution.</li>
<li>Developed in the 1980s and popularized in the 1990s, MCMC algorithms
quickly eliminated the need for analytical marginalizations of single
parameters from joint multi-dimensional posteriors.</li>
<li>The core idea:
<ul>
<li><em>Markov Chains</em> wander through, and take samples from, the
parameter space.Following an initial warmup period, the Markov Chains
will converge to high-density regions of the underlying posterior
distribution (ergodicity).</li>
<li>The proportion of “steps” in a given region of multidimensional
parameter space gives a stochastic simulation of the posterior
probability density.</li>
<li>This yields a numerical approximation of the underlying posterior
distribution, much like Monte Carlo simulations of MLE parameters yield
numerical approximations of the underlying sampling distribution.</li>
</ul></li>
</ul>
</div>
<div id="section-some-mcmc-algorithms" class="section level3">
<h3>(Some) MCMC Algorithms</h3>
<ol style="list-style-type: decimal">
<li><strong>Gibbs</strong>: Draws iteratively and alternatively from the
conditional conjugate distribution of each parameter.</li>
<li><strong>Metropolis-Hastings</strong>: Considers a single
multidimensional move on each iteration depending on the quality of the
proposed candidate draw.</li>
<li><strong>Hamiltonian Monte Carlo (HMC)</strong>, used in Stan:</li>
</ol>
<blockquote>
<sub> The Hamiltonian Monte Carlo algorithm starts at a specified
initial set of parameters <span class="math inline">\(\theta\)</span>;
in Stan, this value is either user-specified or generated randomly.
Then, for a given number of iterations, a new momentum vector is sampled
and the current value of the parameter <span
class="math inline">\(\theta\)</span> is updated using the leapfrog
integrator with discretization time <span
class="math inline">\(\epsilon\)</span> and number of steps <span
class="math inline">\(L\)</span> according to the Hamiltonian dynamics.
Then a Metropolis acceptance step is applied, and a decision is made
whether to update to the new state <span
class="math inline">\((\theta^{\ast},\rho{\ast})\)</span> or keep the
existing state. </sub>
</blockquote>
<div style="text-align: right">
<p><sub><sup> Source: <a
href="https://mc-stan.org/docs/2_19/reference-manual/hamiltonian-monte-carlo.html">Stan
Reference Manual, Section 14.1</a> </sub></sup></p>
</div>
</div>
</div>
<div id="section-implementing-a-gibbs-sampler" class="section level2">
<h2>Implementing a Gibbs sampler</h2>
<div id="section-in-a-nutshell" class="section level3">
<h3>In a nutshell</h3>
<ul>
<li>We want to perform inference on a variable <span
class="math inline">\(y\)</span>, of which we have <span
class="math inline">\(N\)</span> observations.</li>
<li>We stipulate that the data-generating process that produces <span
class="math inline">\(y\)</span> is normal: <span
class="math inline">\(\mathbf{y} \sim \text{N}(\mu, \sigma^2)\)</span>.
This yields a two-dimensional parameter space.</li>
<li>For reasons of convenience, we parameterize the variance of this
normal distribution in terms of its precision <span
class="math inline">\(\tau = \frac{1}{\sigma^2}\)</span>, not in terms
of its standard deviation or variance.</li>
<li>Note, however, that <code>rnorm()</code> in R uses the standard
deviation, which is <code>sqrt(1 / tau)</code>.</li>
<li>We will use a <em>Gibbs sampler</em>. Remember that Gibbs draws
iteratively and alternatively from the conditional conjugate
distribution of each parameter.</li>
<li>We thus need some analytical preliminaries: Namely, analytical forms
for the posterior distributions of the two parameters from whose
marginal posteriors we would like to sample.</li>
<li>This will <em>not</em> involve marginalizing out the “unwanted”
parameters; instead, we will derive the posteriors of <span
class="math inline">\(\mu\)</span> and <span
class="math inline">\(\tau\)</span> as conditional functions of <span
class="math inline">\(\tau\)</span> and <span
class="math inline">\(\mu\)</span>, respectively</li>
</ul>
</div>
<div id="section-application" class="section level3">
<h3>Application</h3>
<ul>
<li>Specifically, we will focus on the variable <code>sup_afd</code>
from the data set <code>gles</code>.</li>
<li>Let’s pretend our prior belief is completely naive:
<ul>
<li>We don’t know how (un)popular the AfD is in the German
electorate</li>
<li>But we know that individual support is measured on a -5 to 5
scale</li>
<li>Our prior belief for <span class="math inline">\(\mu\)</span> should
thus be agnostic as to whether people like or dislike the AfD and
sufficiently vague to allow for the possibility that we may be wrong:
<span class="math inline">\(\mu \sim \text{N}(\theta = 0, \omega^{-1} =
10)\)</span> (mean <span class="math inline">\(\theta\)</span> and
precision <span class="math inline">\(\omega\)</span> are
hyperparameters for the prior of <span
class="math inline">\(\mu\)</span>)</li>
<li>Our prior belief for <span class="math inline">\(\tau\)</span> will
also be vague: <span class="math inline">\(\tau \sim \Gamma(\alpha = 20,
\beta = 200)\)</span> (shape <span class="math inline">\(\alpha\)</span>
and rate <span class="math inline">\(\beta\)</span> are hyperparameters
for the prior of <span class="math inline">\(\tau\)</span>)</li>
<li>We have no prior belief about the dependence of both parameters and
hence specify independent prior distributions</li>
</ul></li>
</ul>
</div>
<div id="section-analytical-preliminaries-mu" class="section level3">
<h3>Analytical preliminaries: <span
class="math inline">\(\mu\)</span></h3>
<p>Our prior belief is that <span class="math inline">\(\mu\)</span> is
distributed normal with mean <span class="math inline">\(\theta =
0\)</span> and precision <span class="math inline">\(\omega =
.1\)</span>:</p>
<p><span class="math display">\[\mu \sim \text{N}(0, 10)\]</span></p>
<p>The prior pdf is given by:</p>
<p><span class="math display">\[
p(\mu | \theta, \omega) = \sqrt{\frac{\omega}{2 \pi}} \exp \left
(-\frac{\omega (\mu - \theta)^2}{2} \right)
\]</span></p>
<p>while the likelihood for the data <span
class="math inline">\(\mathbf{y}\)</span> is given by</p>
<p><span class="math display">\[
p(\mathbf{y} | \mu, \tau) = \prod_{i}^{N} \sqrt{\frac{\tau}{2\pi}}
\exp\left(-\frac{\tau(y_i-\mu)^2}{2} \right)
\]</span></p>
<p>Multiplying prior and likelihood and performing some algebraic
transformations, we see that our conditional posterior density will
be</p>
<p><span class="math display">\[
p(\mu | \theta, \omega, \tau, \mathbf{y}) \propto \exp
\left(-\frac{\omega + N \tau}{2}  \left(\mu - \frac{\omega \theta + N
\tau \bar{y}}{\omega + N \tau}\right)^2 \right)
\]</span></p>
<p>We recognize this as the normal pdf with updated mean parameter <span
class="math inline">\(\theta^{\ast} = \frac{\omega \theta + N \tau
\bar{y}}{\omega + N \tau}\)</span> and updated precision parameter <span
class="math inline">\(\omega^{\ast} = \omega + N \tau\)</span>.</p>
<p>This gives us the required analytical solutions for the normal
parameters that characterize the posterior density of <span
class="math inline">\(\mu\)</span>.</p>
</div>
<div id="section-analytical-preliminaries-tau" class="section level3">
<h3>Analytical preliminaries: <span
class="math inline">\(\tau\)</span></h3>
<p>Furthermore, for our prior knowledge about the precision, we assume
that <span class="math inline">\(\tau\)</span> is Gamma-distributed with
shape <span class="math inline">\(\alpha=20\)</span> and rate <span
class="math inline">\(\beta = 200\)</span>: <span
class="math inline">\(\tau \sim \Gamma(20, 200)\)</span> which yields
the prior pdf:</p>
<p><span class="math display">\[
p(\tau | \alpha, \beta) =  \frac{\beta^{\alpha}}{\Gamma(\alpha)}
\tau^{\alpha - 1} \exp(-\beta \tau)
\]</span></p>
<p>while the likelihood for the data is still given by</p>
<p><span class="math display">\[
p(\mathbf{y} | \mu, \tau) = \prod_{i}^{N} \sqrt{\frac{\tau}{2\pi}}
\exp\left(-\frac{\tau(y_i-\mu)^2}{2}\right)
\]</span></p>
<p>Once again taking the product and rearranging, we find that the
conditional posterior pdf of <span class="math inline">\(\tau\)</span>
is given by</p>
<p><span class="math display">\[
p(\tau | \alpha, \beta, \mu, \mathbf{y}) \propto \tau^{\alpha +
\frac{N}{2} - 1} \exp\left(-\left(\beta + \sum_{i=1}^{N} \frac{(y_i -
\mu)^2}{2} \tau\right)\right)
\]</span></p>
<p>This is a gamma distribution with updated parameters <span
class="math inline">\(\alpha^{\ast} = \alpha + \frac{N}{2}\)</span> and
<span class="math inline">\(\beta^{\ast} = \beta + \sum_{i=1}^{N}
\frac{(y_i - \mu)^2}{2}\)</span>. Thus, we also have analytical
solutions for the Gamma parameters that characterize the posterior
density of <span class="math inline">\(\tau\)</span>.</p>
</div>
<div id="section-simulating-the-independent-prior-distributions"
class="section level3">
<h3>Simulating the independent prior distributions</h3>
<details>
<summary>
Code: Function for simulating the priors
</summary>
<pre class="r"><code># Function
draw_from_prior &lt;-
  function(theta,
           omega,
           alpha,
           beta,
           n_draws,
           seed = 20210329) {
    # Set seed
    set.seed(seed)
    
    # Take draws
    mu &lt;- rnorm(n_draws, theta, 1 / sqrt(omega))
    tau &lt;- rgamma(n_draws, alpha, beta)
    
    ## Return output
    return(list(mu = mu,
                tau = tau))
  }</code></pre>
</details>
<div class="tutorial-exercise" data-label="prior-sim"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="20">
<pre class="text"><code># Apply function
draws_prior &lt;-
  draw_from_prior(
    theta = 0,
    omega = .1,
    alpha = 20,
    beta = 200,
    n_draws = 4000
  )

# Plots of Marginal Densities
par(mfrow = c(1, 3), oma = c(0, 0, 3, 0))
plot(density(draws_prior$mu),
     main = expression(&quot;Marginal Density of&quot; ~ mu))
plot(density(draws_prior$tau),
     main = expression(&quot;Marginal Density of&quot; ~ tau))
plot(density(1 / draws_prior$tau),
     main = expression(&quot;Marginal Density of&quot; ~ sigma^2))
title(&quot;Prior Distribution of Mean and Precision&quot;, outer = T)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-implementing-the-gibbs-sampler-for-the-posterior"
class="section level3">
<h3>Implementing the Gibbs sampler for the posterior</h3>
<details>
<summary>
Code: Gibbs sampler for the posterior
</summary>
<pre class="r"><code># Define function
draw_from_posterior &lt;- function(theta,
                                omega,
                                alpha,
                                beta,
                                n_warmup,
                                n_draws,
                                data,
                                seed = 20210329,
                                keep_warmup = TRUE) {
  # Set seed
  set.seed(seed)

  # Length of chain
  len_chain &lt;- n_warmup + n_draws
  
  # Data characteristics
  n_data &lt;- length(data)  
  mean_data &lt;- mean(data) 

  # Initialize containers
  mu &lt;- rep(NA, len_chain)
  tau &lt;- rep(NA, len_chain)
  
  # Run Gibbs sampler
  for (i in seq_len(len_chain)) {
    if (i == 1) {
      ## Iteration 1: Initialize from prior
      alpha_star &lt;- alpha
      beta_star &lt;- beta
    } else {
      ## Iterations 2+: Update alpha and beta
      alpha_star &lt;- alpha + n_data / 2
      beta_star &lt;- beta + sum(((data - mu[i - 1]) ^ 2) / 2)
    }
    
    ## Sample tau
    tau[i] &lt;- rgamma(1, alpha_star, beta_star)
    
    ## Update theta and omega
    theta_star &lt;-
      (omega * theta + n_data * tau[i] * mean_data) /
      (omega + n_data * tau[i])
    omega_star &lt;- omega + n_data * tau[i]
    
    ## Sample mu
    mu[i] &lt;- rnorm(1, theta_star, 1 / sqrt(omega_star))
  }
  
  ## Conditionally discard warmup-draws
  if (!keep_warmup) {
    tau &lt;- tau[(n_warmup + 1):len_chain]
    mu &lt;- mu[(n_warmup + 1):len_chain]
  }
  
  ## Return output
  return(list(mu = mu,
              tau = tau))
}</code></pre>
</details>
<div class="tutorial-exercise" data-label="posterior-sim"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="30">
<pre class="text"><code># Apply function
draws_posterior &lt;-
  draw_from_posterior(
    theta = 0,
    omega = .1,
    alpha = 20,
    beta = 200,
    n_warmup = 1000,
    n_draws = 1000,
    data = gles$sup_afd,
    keep_warmup = TRUE
  )

draws_posterior_post_warmup &lt;-
  draw_from_posterior(
    theta = 0,
    omega = .1,
    alpha = 20,
    beta = 200,
    n_warmup = 1000,
    n_draws = 1000,
    data = gles$sup_afd,
    keep_warmup = FALSE
  )

# Plots of Marginal Densities and Trace Plots
par(mfrow = c(3, 2),
    oma = c(0, 0, 3, 0))

# Plot  mu
plot(
  seq_along(draws_posterior$mu),
  draws_posterior$mu,
  type = &quot;l&quot;,
  lwd = .3,
  main = expression(&quot;Trace Plot for&quot; ~ mu),
  xlab = &quot;Draws&quot;,
  ylab = expression(mu)
)
lines(predict(loess(
  draws_posterior$mu ~ seq_along(draws_posterior$mu), span = .1
)),
col = &#39;red&#39;, lwd = 1)
plot(density(draws_posterior_post_warmup$mu),
     main = expression(&quot;Marginal Density of&quot; ~ mu))

# Plot tau
plot(
  seq_along(draws_posterior$tau),
  draws_posterior$tau,
  type = &quot;l&quot;,
  lwd = .3,
  main = expression(&quot;Trace Plot for&quot; ~ tau),
  xlab = &quot;Draws&quot;,
  ylab = expression(tau)
)
lines(predict(loess(
  draws_posterior$tau ~ seq_along(draws_posterior$tau), span = .1
)),
col = &#39;red&#39;, lwd = 1)
plot(density(draws_posterior_post_warmup$tau),
     main = expression(&quot;Marginal Density of&quot; ~ tau))
title(&quot;Posterior Distribution of Mean and Precision&quot;, outer = T)

# Plot sigma^2
plot(
  seq_along(draws_posterior$tau),
  1 / draws_posterior$tau,
  type = &quot;l&quot;,
  lwd = .3,
  main = expression(&quot;Trace Plot for&quot; ~ sigma ^ 2),
  xlab = &quot;Draws&quot;,
  ylab = expression(tau)
)
lines(predict(loess(
  I(1 / draws_posterior$tau) ~ seq_along(draws_posterior$tau), span = .1)),
col = &#39;red&#39;, lwd = 1)
plot(density(1 / draws_posterior_post_warmup$tau),
     main = expression(&quot;Marginal Density of&quot; ~ sigma ^ 2))
title(&quot;Posterior Distribution of Mean and Precision&quot;, outer = T)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-how-the-sampler-explores-the-joint-posterior-density"
class="section level3">
<h3>How the sampler explores the joint posterior density</h3>
<div class="tutorial-exercise" data-label="joint-posterior"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="30">
<pre class="text"><code># Apply function
draws_posterior &lt;-
  draw_from_posterior(
    theta = 0,
    omega = .1,
    alpha = 20,
    beta = 200,
    n_warmup = 100,
    n_draws = 1000,
    data = gles$sup_afd,
    keep_warmup = TRUE
  )

# Save as matrix, transform precision to variance
draws_posterior &lt;- simplify2array(draws_posterior)
draws_posterior[, 2] &lt;- 1 / draws_posterior[, 2]

# Plot
for (i in seq_len(nrow(draws_posterior))) {
  if (i == 1) {
    plot(
      draws_posterior[i, 1],
      draws_posterior[i, 2],
      pch = 23,
      xlim = range(draws_posterior[, 1]),
      ylim = range(draws_posterior[, 2]),
      main = &quot;Exploration of the joint posterior&quot;,
      xlab = expression(mu),
      ylab = expression(sigma ^ 2),
      col = NA,
      bg = adjustcolor(&quot;red&quot;, alpha.f = 0.25)
    )
  } else {
    segments(
      draws_posterior[i - 1, 1],
      draws_posterior[i - 1, 2],
      draws_posterior[i - 1, 1],
      draws_posterior[i, 2],
      col = adjustcolor(&quot;gray10&quot;, alpha.f = 0.05),
      lwd = 3
    )
    segments(
      draws_posterior[i - 1, 1],
      draws_posterior[i, 2],
      draws_posterior[i, 1],
      draws_posterior[i, 2],
      col = adjustcolor(&quot;gray10&quot;, alpha.f = 0.05),
      lwd = 3
    )
    points(
      draws_posterior[i, 1],
      draws_posterior[i, 2],
      pch = 21,
      col = NA,
      bg = adjustcolor(&quot;gray10&quot;, alpha.f = 0.25)
    )
  }
}</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<div id="section-convergence-diagnostics" class="section level2">
<h2>Convergence diagnostics</h2>
<div id="section-why-diagnose" class="section level3">
<h3>Why diagnose?</h3>
<p>MCMC algorithms use iterative algorithms to explore posterior
distributions and to produce numerical approximations thereof.</p>
<p>However, even with appropriately specified models and algorithms, we
can never know a priori if and when a chain has converged to its target
distribution. We must thus rely on <em>convergence diagnostics</em>.</p>
<p><em>Important:</em> Convergence diagnostics cannot show or prove
convergence. They can only show signs of non-convergence!</p>
<p>To conclude that the post-warmup draws of our sampler in fact explore
the target distribution, we want to show at least two things:</p>
<ol style="list-style-type: decimal">
<li>Every chain is in a stationary state (i.e., does not “wander off”
the target distribution)</li>
<li>Multiple independent chains are in the same stationary state (i.e.,
no convergence to different target distributions given identical
data)</li>
</ol>
</div>
<div id="section-generic-diagnostics" class="section level3">
<h3>Generic diagnostics</h3>
<p>Generic diagnostics (see <a
href="https://www.routledge.com/Bayesian-Methods-A-Social-and-Behavioral-Sciences-Approach-Third-Edition/Gill/p/book/9781439862483">Gill
2015, Ch. 14.3</a>) include:</p>
<ol style="list-style-type: decimal">
<li><strong>Potential scale reduction statistic</strong> <span
class="math inline">\(\hat{R}\)</span> (aka Gelman-Rubin convergence
diagnostic) <span class="math display">\[\small \widehat{Var}(\theta) =
(1 - \frac{1}{\mathtt{n_{iter}}})
\underbrace{\Bigg(\frac{1}{ \mathtt{n_{chains}} (\mathtt{n_{iter}} - 1)}
\sum_{j=1}^{\mathtt{n_{chains}}} \sum_{i=1}^{\mathtt{n_{iter}}}
(\theta_{ij} - \bar{\theta_j})^2 \Bigg)}_{\text{Within chain var}} +
\frac{1}{\mathtt{n_{iter}}}  \underbrace{\Bigg(\frac{\mathtt{n_{iter}}}{\mathtt{n_{chains}
- 1}} \sum_{j=1}^{\mathtt{n_{chains}}} (\bar{\theta_j} -
\bar{\bar{\theta}})^2\Bigg)}_{\text{Between chain var}}\]</span>
<ul>
<li>low values indicate that chains are stationary (convergence to
target distribution within chains)</li>
<li>low values indicate that chains mix (convergence to same target
distribution across chains)</li>
</ul></li>
<li><strong>Geweke Time-Series Diagnostic</strong>: Compare
non-overlapping post-warmup portions of each chain to test
within-convergence</li>
<li><strong>Heidelberger and Welch Diagnostic</strong>: Compare early
post-warmup portion of each chain with late portion to test
within-convergence</li>
<li><strong>Raftery and Lewis Integrated Diagnostic</strong>: Evaluates
the full chain of a pilot run (requires that
<code>save_warmup = TRUE</code>) to estimate minimum required length of
warmup and sampling</li>
</ol>
<p>These are implemented as part of the <code>coda</code> package
(Output Analysis and Diagnostics for MCMC).</p>
</div>
<div id="section-visual-diagnostics" class="section level3">
<h3>Visual diagnostics</h3>
<p>The most widespread visual diagnostics are:</p>
<ol style="list-style-type: decimal">
<li><strong>Traceplots</strong>: Visually inspect if chains are
stationary and have converged to the same distribution</li>
<li><strong>Autocorrelation plots</strong>: Visually inspect if the
chain is sluggish in exploring the parameter space.</li>
</ol>
</div>
<div id="section-application-1" class="section level3">
<h3>Application</h3>
<p>In the following, we will use multiple chain runs of our sampler in
conjunction with the <code>coda</code> package to check for signs of
non-convergence.</p>
<p>Note that <code>coda</code> functions require that we combine our
chains into <code>mcmc.list</code> objects.</p>
</div>
<div id="section-raftery-and-lewis-integrated-diagnostic"
class="section level3">
<h3>Raftery and Lewis Integrated Diagnostic</h3>
<p>The Raftery-Lewis diagnostic takes a single chain, including warm-up
draws, to estimate the minimum required length of warmup and sampling
runs:</p>
<div class="tutorial-exercise" data-label="raftery-lewis"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Example: Gill 2015, p. 503
# If we want a 95% credible interval around the median 
# with reliability between 92.5% and 97.5%, we need:
q &lt;- 0.5    # quantile of interest
r &lt;- 0.0125 # margin of error
s &lt;- 0.95   # desired reliability

## The recommend length for the pilot run:
n &lt;- ceiling((qnorm(.5 * (s + 1)) * sqrt(q * (1 - q)) / r) ^ 2)

# Pilot run
draws_pilot &lt;-
  draw_from_posterior(
    theta = 0,
    omega = .1,
    alpha = 20,
    beta = 200,
    n_warmup = 0,
    n_draws = n,
    data = gles$sup_afd,
    keep_warmup = TRUE
  )

# Save as mcmc
draws_pilot &lt;- as.mcmc(simplify2array(draws_pilot))

# Diagnose
raftery.diag(
  draws_pilot,
  q = q,
  r = r,
  s = s
)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-gelman-rubin-geweke-and-heidelberger-welch-diagnostics"
class="section level3">
<h3>Gelman-Rubin, Geweke, and Heidelberger-Welch diagnostics</h3>
<p>We will use the recommended run-length from the Raftery-Lewis
diagnostic for four independent runs of our sampler.</p>
<p>We will ensure that ou chains run independently (i.e., using
different starting values and different random number sequences) by
setting different seed:</p>
<pre class="r"><code>seeds &lt;- sample(10001:99999, 4)
draws_multiple_chains &lt;- lapply(seeds,
                                function(seed) {
                                  as.mcmc(simplify2array(
                                    draw_from_posterior(
                                      theta = 0,
                                      omega = .1,
                                      alpha = 20,
                                      beta = 200,
                                      n_warmup = 200,
                                      n_draws = 6147,
                                      data = gles$sup_afd,
                                      keep_warmup = FALSE,
                                      seed = seed
                                    )
                                  ))
                                })

# Save as mcmc.list
draws_multiple_chains &lt;- as.mcmc.list(draws_multiple_chains)</code></pre>
<div class="tutorial-exercise" data-label="other-diagnostics"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Diagnose
coda::gelman.diag(draws_multiple_chains, autoburnin = FALSE)
coda::geweke.diag(draws_multiple_chains, frac1 = .1, frac2 = .5)  
coda::heidel.diag(draws_multiple_chains, pvalue = .1)             </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-trace-plots" class="section level3">
<h3>Trace plots</h3>
<div class="tutorial-exercise" data-label="trace" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>par(mfrow = c(1, 2))
coda::traceplot(draws_multiple_chains, smooth = TRUE)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-autocorrelation-plots" class="section level3">
<h3>Autocorrelation plots</h3>
<div class="tutorial-exercise" data-label="autocorr" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>coda::autocorr.plot(draws_multiple_chains)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<div id="section-contrasting-bayesian-and-frequentist-approaches"
class="section level2">
<h2>Contrasting Bayesian and frequentist approaches</h2>
<div id="section-priors" class="section level3">
<h3>Priors</h3>
<ul>
<li>Choice of priors allows us to explicitly incorporate prior beliefs
about parameters…</li>
<li>…but also comes with the obligation to be transparent and
responsible with respect to the subjectivity this brings into our
analyses</li>
</ul>
</div>
<div id="section-inference" class="section level3">
<h3>Inference</h3>
<div id="section-interpretation" class="section level4">
<h4>Interpretation</h4>
<ul>
<li>Bayesian inference does note presume large (quasi-infinite) streams
of independent identically distributed (IID) data; data are considered
fixed, parameters random.</li>
<li>This allows for straightforward interpretations of inferential
uncertainty:
<ul>
<li><em>Bayesian</em>: “Given the data, we can conclude that there is a
95% probability that the mean is between 8 and 12, with highest
probability density at a value of 10”.</li>
<li><em>Frequentist</em>: “If we took a large number of independent
random samples from the same population and constructed a 95% confidence
interval around the sample for each of them, these confidence intervals
would contain the <em>true</em> population mean 95% of the time. Given
this long-run frequency, we are 95% confident that the specific 95%
confidence intervals from our singular sample contains the true
population parameter…”.</li>
</ul></li>
</ul>
</div>
<div id="section-finite-sample-and-asymptotic-properties"
class="section level4">
<h4>Finite-sample and asymptotic properties</h4>
<ul>
<li>Bayesian inference allows for exact inference in finite-sample
applications where the asymptotic properties of MLE estimators are
implausible (normal approximation, etc.)…</li>
<li>…yet, posterior distribution often asymptotically converge to the
sampling distribution of MLE estimators (<a
href="https://en.wikipedia.org/wiki/Bernstein%E2%80%93von_Mises_theorem">Bernstein-von-Mises
Theorem</a>)</li>
</ul>
</div>
</div>
<div id="section-flexibility-and-computational-reliability"
class="section level3">
<h3>Flexibility and computational reliability</h3>
<ul>
<li>The use of MCMC algorithms for probabilistic approximate inference
makes Bayesian approaches incredibly flexible and allows for
computationally reliable estimation of complex, analytically intractable
marginal likelihoods (avoids integration of super high-dimensional
integrals)…</li>
<li>…but sometimes comes with the necessity of high computational
resources and/or long computation times, and always necessitates
convergence diagnosis and model checking 
<script type="application/shiny-prerendered" data-context="server-start">
## --- learnr ---
if ("learnr" %in% (.packages()))
  detach(package:learnr, unload = TRUE)
library(learnr)
knitr::opts_chunk$set(echo = FALSE)

## ---- CRAN Packages ----
## Save package names as a vector of strings
pkgs <-  c("coda", "foreign")

## Install uninstalled packages
lapply(pkgs[!(pkgs %in% installed.packages())], 
       install.packages,
       repos='http://cran.us.r-project.org')

## Load all packages to library and adjust options
lapply(pkgs, library, character.only = TRUE)

## ---- GitHub Packages ----


## ---- Global learnr Objects ----
gles <- 
  read.dta("https://github.com/denis-cohen/statmodeling/raw/main/data/gles.dta")

draw_from_prior <-
  function(theta,
           omega,
           alpha,
           beta,
           n_draws,
           seed = 20210329) {
    # Set seed
    set.seed(seed)
    
    # Take draws
    mu <- rnorm(n_draws, theta, 1 / sqrt(omega))
    tau <- rgamma(n_draws, alpha, beta)
    
    ## Return output
    return(list(mu = mu,
                tau = tau))
  }

draw_from_posterior <- function(theta,
                                omega,
                                alpha,
                                beta,
                                n_warmup,
                                n_draws,
                                data,
                                seed = 20210329,
                                keep_warmup = TRUE) {
  # Set seed
  set.seed(seed)

  # Length of chain
  len_chain <- n_warmup + n_draws
  
  # Data characteristics
  n_data <- length(data)  
  mean_data <- mean(data) 

  # Initialize containers
  mu <- rep(NA, len_chain)
  tau <- rep(NA, len_chain)
  
  # Run Gibbs sampler
  for (i in seq_len(len_chain)) {
    if (i == 1) {
      ## Iteration 1: Initialize from prior
      alpha_star <- alpha
      beta_star <- beta
    } else {
      ## Iterations 2+: Update alpha and beta
      alpha_star <- alpha + n_data / 2
      beta_star <- beta + sum(((data - mu[i - 1]) ^ 2) / 2)
    }
    
    ## Sample tau
    tau[i] <- rgamma(1, alpha_star, beta_star)
    
    ## Update theta and omega
    theta_star <-
      (omega * theta + n_data * tau[i] * mean_data) /
      (omega + n_data * tau[i])
    omega_star <- omega + n_data * tau[i]
    
    ## Sample mu
    mu[i] <- rnorm(1, theta_star, 1 / sqrt(omega_star))
  }
  
  ## Conditionally discard warmup-draws
  if (!keep_warmup) {
    tau <- tau[(n_warmup + 1):len_chain]
    mu <- mu[(n_warmup + 1):len_chain]
  }
  
  ## Return output
  return(list(mu = mu,
              tau = tau))
}

seeds <- sample(10001:99999, 4)
draws_multiple_chains <- lapply(seeds,
                                function(seed) {
                                  as.mcmc(simplify2array(
                                    draw_from_posterior(
                                      theta = 0,
                                      omega = .1,
                                      alpha = 20,
                                      beta = 200,
                                      n_warmup = 200,
                                      n_draws = 6147,
                                      data = gles$sup_afd,
                                      keep_warmup = FALSE,
                                      seed = seed
                                    )
                                  ))
                                })

# Save as mcmc.list
draws_multiple_chains <- as.mcmc.list(draws_multiple_chains)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::register_http_handlers(session, metadata = NULL)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::prepare_tutorial_state(session)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::i18n_observe_tutorial_language(input, session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
session$onSessionEnded(function() {
        learnr:::event_trigger(session, "session_stop")
      })
</script>


<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-prior-sim-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-prior-sim-code-editor`)), session)
output$`tutorial-exercise-prior-sim-output` <- renderUI({
  `tutorial-exercise-prior-sim-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "prior-sim", global_setup = structure(c("## --- learnr ---", 
"if (\"learnr\" %in% (.packages()))", "  detach(package:learnr, unload = TRUE)", 
"library(learnr)", "knitr::opts_chunk$set(echo = FALSE)", "", 
"## ---- CRAN Packages ----", "## Save package names as a vector of strings", 
"pkgs <-  c(\"coda\", \"foreign\")", "", "## Install uninstalled packages", 
"lapply(pkgs[!(pkgs %in% installed.packages())], ", "       install.packages,", 
"       repos='http://cran.us.r-project.org')", "", "## Load all packages to library and adjust options", 
"lapply(pkgs, library, character.only = TRUE)", "", "## ---- GitHub Packages ----", 
"", "", "## ---- Global learnr Objects ----", "gles <- ", "  read.dta(\"https://github.com/denis-cohen/statmodeling/raw/main/data/gles.dta\")", 
"", "draw_from_prior <-", "  function(theta,", "           omega,", 
"           alpha,", "           beta,", "           n_draws,", 
"           seed = 20210329) {", "    # Set seed", "    set.seed(seed)", 
"    ", "    # Take draws", "    mu <- rnorm(n_draws, theta, 1 / sqrt(omega))", 
"    tau <- rgamma(n_draws, alpha, beta)", "    ", "    ## Return output", 
"    return(list(mu = mu,", "                tau = tau))", "  }", 
"", "draw_from_posterior <- function(theta,", "                                omega,", 
"                                alpha,", "                                beta,", 
"                                n_warmup,", "                                n_draws,", 
"                                data,", "                                seed = 20210329,", 
"                                keep_warmup = TRUE) {", "  # Set seed", 
"  set.seed(seed)", "", "  # Length of chain", "  len_chain <- n_warmup + n_draws", 
"  ", "  # Data characteristics", "  n_data <- length(data)  ", 
"  mean_data <- mean(data) ", "", "  # Initialize containers", 
"  mu <- rep(NA, len_chain)", "  tau <- rep(NA, len_chain)", 
"  ", "  # Run Gibbs sampler", "  for (i in seq_len(len_chain)) {", 
"    if (i == 1) {", "      ## Iteration 1: Initialize from prior", 
"      alpha_star <- alpha", "      beta_star <- beta", "    } else {", 
"      ## Iterations 2+: Update alpha and beta", "      alpha_star <- alpha + n_data / 2", 
"      beta_star <- beta + sum(((data - mu[i - 1]) ^ 2) / 2)", 
"    }", "    ", "    ## Sample tau", "    tau[i] <- rgamma(1, alpha_star, beta_star)", 
"    ", "    ## Update theta and omega", "    theta_star <-", 
"      (omega * theta + n_data * tau[i] * mean_data) /", "      (omega + n_data * tau[i])", 
"    omega_star <- omega + n_data * tau[i]", "    ", "    ## Sample mu", 
"    mu[i] <- rnorm(1, theta_star, 1 / sqrt(omega_star))", "  }", 
"  ", "  ## Conditionally discard warmup-draws", "  if (!keep_warmup) {", 
"    tau <- tau[(n_warmup + 1):len_chain]", "    mu <- mu[(n_warmup + 1):len_chain]", 
"  }", "  ", "  ## Return output", "  return(list(mu = mu,", 
"              tau = tau))", "}", "", "seeds <- sample(10001:99999, 4)", 
"draws_multiple_chains <- lapply(seeds,", "                                function(seed) {", 
"                                  as.mcmc(simplify2array(", 
"                                    draw_from_posterior(", "                                      theta = 0,", 
"                                      omega = .1,", "                                      alpha = 20,", 
"                                      beta = 200,", "                                      n_warmup = 200,", 
"                                      n_draws = 6147,", "                                      data = gles$sup_afd,", 
"                                      keep_warmup = FALSE,", 
"                                      seed = seed", "                                    )", 
"                                  ))", "                                })", 
"", "# Save as mcmc.list", "draws_multiple_chains <- as.mcmc.list(draws_multiple_chains)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "prior-sim", code = "# Apply function\ndraws_prior <-\n  draw_from_prior(\n    theta = 0,\n    omega = .1,\n    alpha = 20,\n    beta = 200,\n    n_draws = 4000\n  )\n\n# Plots of Marginal Densities\npar(mfrow = c(1, 3), oma = c(0, 0, 3, 0))\nplot(density(draws_prior$mu),\n     main = expression(\"Marginal Density of\" ~ mu))\nplot(density(draws_prior$tau),\n     main = expression(\"Marginal Density of\" ~ tau))\nplot(density(1 / draws_prior$tau),\n     main = expression(\"Marginal Density of\" ~ sigma^2))\ntitle(\"Prior Distribution of Mean and Precision\", outer = T)", 
        opts = list(label = "\"prior-sim\"", exercise = "TRUE", 
            exercise.lines = "20", fig.align = "\"center\"", 
            fig.width = "9", fig.height = "5"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = NULL, 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "03-lec_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "center", fig.path = "03-lec_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 9, fig.height = 5, fig.env = "figure", fig.cap = NULL, 
        fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 864, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "prior-sim", exercise = TRUE, 
        exercise.lines = 20, code = c("# Apply function", "draws_prior <-", 
        "  draw_from_prior(", "    theta = 0,", "    omega = .1,", 
        "    alpha = 20,", "    beta = 200,", "    n_draws = 4000", 
        "  )", "", "# Plots of Marginal Densities", "par(mfrow = c(1, 3), oma = c(0, 0, 3, 0))", 
        "plot(density(draws_prior$mu),", "     main = expression(\"Marginal Density of\" ~ mu))", 
        "plot(density(draws_prior$tau),", "     main = expression(\"Marginal Density of\" ~ tau))", 
        "plot(density(1 / draws_prior$tau),", "     main = expression(\"Marginal Density of\" ~ sigma^2))", 
        "title(\"Prior Distribution of Mean and Precision\", outer = T)"
        ), out.width.px = 864, out.height.px = 480, params.src = "prior-sim, exercise=TRUE, exercise.lines = 20, fig.align='center', fig.width = 9, fig.height=5", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>


<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-posterior-sim-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-posterior-sim-code-editor`)), session)
output$`tutorial-exercise-posterior-sim-output` <- renderUI({
  `tutorial-exercise-posterior-sim-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "posterior-sim", global_setup = structure(c("## --- learnr ---", 
"if (\"learnr\" %in% (.packages()))", "  detach(package:learnr, unload = TRUE)", 
"library(learnr)", "knitr::opts_chunk$set(echo = FALSE)", "", 
"## ---- CRAN Packages ----", "## Save package names as a vector of strings", 
"pkgs <-  c(\"coda\", \"foreign\")", "", "## Install uninstalled packages", 
"lapply(pkgs[!(pkgs %in% installed.packages())], ", "       install.packages,", 
"       repos='http://cran.us.r-project.org')", "", "## Load all packages to library and adjust options", 
"lapply(pkgs, library, character.only = TRUE)", "", "## ---- GitHub Packages ----", 
"", "", "## ---- Global learnr Objects ----", "gles <- ", "  read.dta(\"https://github.com/denis-cohen/statmodeling/raw/main/data/gles.dta\")", 
"", "draw_from_prior <-", "  function(theta,", "           omega,", 
"           alpha,", "           beta,", "           n_draws,", 
"           seed = 20210329) {", "    # Set seed", "    set.seed(seed)", 
"    ", "    # Take draws", "    mu <- rnorm(n_draws, theta, 1 / sqrt(omega))", 
"    tau <- rgamma(n_draws, alpha, beta)", "    ", "    ## Return output", 
"    return(list(mu = mu,", "                tau = tau))", "  }", 
"", "draw_from_posterior <- function(theta,", "                                omega,", 
"                                alpha,", "                                beta,", 
"                                n_warmup,", "                                n_draws,", 
"                                data,", "                                seed = 20210329,", 
"                                keep_warmup = TRUE) {", "  # Set seed", 
"  set.seed(seed)", "", "  # Length of chain", "  len_chain <- n_warmup + n_draws", 
"  ", "  # Data characteristics", "  n_data <- length(data)  ", 
"  mean_data <- mean(data) ", "", "  # Initialize containers", 
"  mu <- rep(NA, len_chain)", "  tau <- rep(NA, len_chain)", 
"  ", "  # Run Gibbs sampler", "  for (i in seq_len(len_chain)) {", 
"    if (i == 1) {", "      ## Iteration 1: Initialize from prior", 
"      alpha_star <- alpha", "      beta_star <- beta", "    } else {", 
"      ## Iterations 2+: Update alpha and beta", "      alpha_star <- alpha + n_data / 2", 
"      beta_star <- beta + sum(((data - mu[i - 1]) ^ 2) / 2)", 
"    }", "    ", "    ## Sample tau", "    tau[i] <- rgamma(1, alpha_star, beta_star)", 
"    ", "    ## Update theta and omega", "    theta_star <-", 
"      (omega * theta + n_data * tau[i] * mean_data) /", "      (omega + n_data * tau[i])", 
"    omega_star <- omega + n_data * tau[i]", "    ", "    ## Sample mu", 
"    mu[i] <- rnorm(1, theta_star, 1 / sqrt(omega_star))", "  }", 
"  ", "  ## Conditionally discard warmup-draws", "  if (!keep_warmup) {", 
"    tau <- tau[(n_warmup + 1):len_chain]", "    mu <- mu[(n_warmup + 1):len_chain]", 
"  }", "  ", "  ## Return output", "  return(list(mu = mu,", 
"              tau = tau))", "}", "", "seeds <- sample(10001:99999, 4)", 
"draws_multiple_chains <- lapply(seeds,", "                                function(seed) {", 
"                                  as.mcmc(simplify2array(", 
"                                    draw_from_posterior(", "                                      theta = 0,", 
"                                      omega = .1,", "                                      alpha = 20,", 
"                                      beta = 200,", "                                      n_warmup = 200,", 
"                                      n_draws = 6147,", "                                      data = gles$sup_afd,", 
"                                      keep_warmup = FALSE,", 
"                                      seed = seed", "                                    )", 
"                                  ))", "                                })", 
"", "# Save as mcmc.list", "draws_multiple_chains <- as.mcmc.list(draws_multiple_chains)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "posterior-sim", code = "# Apply function\ndraws_posterior <-\n  draw_from_posterior(\n    theta = 0,\n    omega = .1,\n    alpha = 20,\n    beta = 200,\n    n_warmup = 1000,\n    n_draws = 1000,\n    data = gles$sup_afd,\n    keep_warmup = TRUE\n  )\n\ndraws_posterior_post_warmup <-\n  draw_from_posterior(\n    theta = 0,\n    omega = .1,\n    alpha = 20,\n    beta = 200,\n    n_warmup = 1000,\n    n_draws = 1000,\n    data = gles$sup_afd,\n    keep_warmup = FALSE\n  )\n\n# Plots of Marginal Densities and Trace Plots\npar(mfrow = c(3, 2),\n    oma = c(0, 0, 3, 0))\n\n# Plot  mu\nplot(\n  seq_along(draws_posterior$mu),\n  draws_posterior$mu,\n  type = \"l\",\n  lwd = .3,\n  main = expression(\"Trace Plot for\" ~ mu),\n  xlab = \"Draws\",\n  ylab = expression(mu)\n)\nlines(predict(loess(\n  draws_posterior$mu ~ seq_along(draws_posterior$mu), span = .1\n)),\ncol = 'red', lwd = 1)\nplot(density(draws_posterior_post_warmup$mu),\n     main = expression(\"Marginal Density of\" ~ mu))\n\n# Plot tau\nplot(\n  seq_along(draws_posterior$tau),\n  draws_posterior$tau,\n  type = \"l\",\n  lwd = .3,\n  main = expression(\"Trace Plot for\" ~ tau),\n  xlab = \"Draws\",\n  ylab = expression(tau)\n)\nlines(predict(loess(\n  draws_posterior$tau ~ seq_along(draws_posterior$tau), span = .1\n)),\ncol = 'red', lwd = 1)\nplot(density(draws_posterior_post_warmup$tau),\n     main = expression(\"Marginal Density of\" ~ tau))\ntitle(\"Posterior Distribution of Mean and Precision\", outer = T)\n\n# Plot sigma^2\nplot(\n  seq_along(draws_posterior$tau),\n  1 / draws_posterior$tau,\n  type = \"l\",\n  lwd = .3,\n  main = expression(\"Trace Plot for\" ~ sigma ^ 2),\n  xlab = \"Draws\",\n  ylab = expression(tau)\n)\nlines(predict(loess(\n  I(1 / draws_posterior$tau) ~ seq_along(draws_posterior$tau), span = .1)),\ncol = 'red', lwd = 1)\nplot(density(1 / draws_posterior_post_warmup$tau),\n     main = expression(\"Marginal Density of\" ~ sigma ^ 2))\ntitle(\"Posterior Distribution of Mean and Precision\", outer = T)", 
        opts = list(label = "\"posterior-sim\"", exercise = "TRUE", 
            exercise.lines = "30", fig.align = "\"center\"", 
            fig.width = "9", fig.height = "9"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = NULL, 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "03-lec_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "center", fig.path = "03-lec_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 9, fig.height = 9, fig.env = "figure", fig.cap = NULL, 
        fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 864, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "posterior-sim", exercise = TRUE, 
        exercise.lines = 30, code = c("# Apply function", "draws_posterior <-", 
        "  draw_from_posterior(", "    theta = 0,", "    omega = .1,", 
        "    alpha = 20,", "    beta = 200,", "    n_warmup = 1000,", 
        "    n_draws = 1000,", "    data = gles$sup_afd,", "    keep_warmup = TRUE", 
        "  )", "", "draws_posterior_post_warmup <-", "  draw_from_posterior(", 
        "    theta = 0,", "    omega = .1,", "    alpha = 20,", 
        "    beta = 200,", "    n_warmup = 1000,", "    n_draws = 1000,", 
        "    data = gles$sup_afd,", "    keep_warmup = FALSE", 
        "  )", "", "# Plots of Marginal Densities and Trace Plots", 
        "par(mfrow = c(3, 2),", "    oma = c(0, 0, 3, 0))", "", 
        "# Plot  mu", "plot(", "  seq_along(draws_posterior$mu),", 
        "  draws_posterior$mu,", "  type = \"l\",", "  lwd = .3,", 
        "  main = expression(\"Trace Plot for\" ~ mu),", "  xlab = \"Draws\",", 
        "  ylab = expression(mu)", ")", "lines(predict(loess(", 
        "  draws_posterior$mu ~ seq_along(draws_posterior$mu), span = .1", 
        ")),", "col = 'red', lwd = 1)", "plot(density(draws_posterior_post_warmup$mu),", 
        "     main = expression(\"Marginal Density of\" ~ mu))", 
        "", "# Plot tau", "plot(", "  seq_along(draws_posterior$tau),", 
        "  draws_posterior$tau,", "  type = \"l\",", "  lwd = .3,", 
        "  main = expression(\"Trace Plot for\" ~ tau),", "  xlab = \"Draws\",", 
        "  ylab = expression(tau)", ")", "lines(predict(loess(", 
        "  draws_posterior$tau ~ seq_along(draws_posterior$tau), span = .1", 
        ")),", "col = 'red', lwd = 1)", "plot(density(draws_posterior_post_warmup$tau),", 
        "     main = expression(\"Marginal Density of\" ~ tau))", 
        "title(\"Posterior Distribution of Mean and Precision\", outer = T)", 
        "", "# Plot sigma^2", "plot(", "  seq_along(draws_posterior$tau),", 
        "  1 / draws_posterior$tau,", "  type = \"l\",", "  lwd = .3,", 
        "  main = expression(\"Trace Plot for\" ~ sigma ^ 2),", 
        "  xlab = \"Draws\",", "  ylab = expression(tau)", ")", 
        "lines(predict(loess(", "  I(1 / draws_posterior$tau) ~ seq_along(draws_posterior$tau), span = .1)),", 
        "col = 'red', lwd = 1)", "plot(density(1 / draws_posterior_post_warmup$tau),", 
        "     main = expression(\"Marginal Density of\" ~ sigma ^ 2))", 
        "title(\"Posterior Distribution of Mean and Precision\", outer = T)"
        ), out.width.px = 864, out.height.px = 864, params.src = "posterior-sim, exercise=TRUE, exercise.lines = 30, fig.align='center', fig.width = 9, fig.height=9", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>


<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-joint-posterior-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-joint-posterior-code-editor`)), session)
output$`tutorial-exercise-joint-posterior-output` <- renderUI({
  `tutorial-exercise-joint-posterior-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "joint-posterior", global_setup = structure(c("## --- learnr ---", 
"if (\"learnr\" %in% (.packages()))", "  detach(package:learnr, unload = TRUE)", 
"library(learnr)", "knitr::opts_chunk$set(echo = FALSE)", "", 
"## ---- CRAN Packages ----", "## Save package names as a vector of strings", 
"pkgs <-  c(\"coda\", \"foreign\")", "", "## Install uninstalled packages", 
"lapply(pkgs[!(pkgs %in% installed.packages())], ", "       install.packages,", 
"       repos='http://cran.us.r-project.org')", "", "## Load all packages to library and adjust options", 
"lapply(pkgs, library, character.only = TRUE)", "", "## ---- GitHub Packages ----", 
"", "", "## ---- Global learnr Objects ----", "gles <- ", "  read.dta(\"https://github.com/denis-cohen/statmodeling/raw/main/data/gles.dta\")", 
"", "draw_from_prior <-", "  function(theta,", "           omega,", 
"           alpha,", "           beta,", "           n_draws,", 
"           seed = 20210329) {", "    # Set seed", "    set.seed(seed)", 
"    ", "    # Take draws", "    mu <- rnorm(n_draws, theta, 1 / sqrt(omega))", 
"    tau <- rgamma(n_draws, alpha, beta)", "    ", "    ## Return output", 
"    return(list(mu = mu,", "                tau = tau))", "  }", 
"", "draw_from_posterior <- function(theta,", "                                omega,", 
"                                alpha,", "                                beta,", 
"                                n_warmup,", "                                n_draws,", 
"                                data,", "                                seed = 20210329,", 
"                                keep_warmup = TRUE) {", "  # Set seed", 
"  set.seed(seed)", "", "  # Length of chain", "  len_chain <- n_warmup + n_draws", 
"  ", "  # Data characteristics", "  n_data <- length(data)  ", 
"  mean_data <- mean(data) ", "", "  # Initialize containers", 
"  mu <- rep(NA, len_chain)", "  tau <- rep(NA, len_chain)", 
"  ", "  # Run Gibbs sampler", "  for (i in seq_len(len_chain)) {", 
"    if (i == 1) {", "      ## Iteration 1: Initialize from prior", 
"      alpha_star <- alpha", "      beta_star <- beta", "    } else {", 
"      ## Iterations 2+: Update alpha and beta", "      alpha_star <- alpha + n_data / 2", 
"      beta_star <- beta + sum(((data - mu[i - 1]) ^ 2) / 2)", 
"    }", "    ", "    ## Sample tau", "    tau[i] <- rgamma(1, alpha_star, beta_star)", 
"    ", "    ## Update theta and omega", "    theta_star <-", 
"      (omega * theta + n_data * tau[i] * mean_data) /", "      (omega + n_data * tau[i])", 
"    omega_star <- omega + n_data * tau[i]", "    ", "    ## Sample mu", 
"    mu[i] <- rnorm(1, theta_star, 1 / sqrt(omega_star))", "  }", 
"  ", "  ## Conditionally discard warmup-draws", "  if (!keep_warmup) {", 
"    tau <- tau[(n_warmup + 1):len_chain]", "    mu <- mu[(n_warmup + 1):len_chain]", 
"  }", "  ", "  ## Return output", "  return(list(mu = mu,", 
"              tau = tau))", "}", "", "seeds <- sample(10001:99999, 4)", 
"draws_multiple_chains <- lapply(seeds,", "                                function(seed) {", 
"                                  as.mcmc(simplify2array(", 
"                                    draw_from_posterior(", "                                      theta = 0,", 
"                                      omega = .1,", "                                      alpha = 20,", 
"                                      beta = 200,", "                                      n_warmup = 200,", 
"                                      n_draws = 6147,", "                                      data = gles$sup_afd,", 
"                                      keep_warmup = FALSE,", 
"                                      seed = seed", "                                    )", 
"                                  ))", "                                })", 
"", "# Save as mcmc.list", "draws_multiple_chains <- as.mcmc.list(draws_multiple_chains)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "joint-posterior", code = "# Apply function\ndraws_posterior <-\n  draw_from_posterior(\n    theta = 0,\n    omega = .1,\n    alpha = 20,\n    beta = 200,\n    n_warmup = 100,\n    n_draws = 1000,\n    data = gles$sup_afd,\n    keep_warmup = TRUE\n  )\n\n# Save as matrix, transform precision to variance\ndraws_posterior <- simplify2array(draws_posterior)\ndraws_posterior[, 2] <- 1 / draws_posterior[, 2]\n\n# Plot\nfor (i in seq_len(nrow(draws_posterior))) {\n  if (i == 1) {\n    plot(\n      draws_posterior[i, 1],\n      draws_posterior[i, 2],\n      pch = 23,\n      xlim = range(draws_posterior[, 1]),\n      ylim = range(draws_posterior[, 2]),\n      main = \"Exploration of the joint posterior\",\n      xlab = expression(mu),\n      ylab = expression(sigma ^ 2),\n      col = NA,\n      bg = adjustcolor(\"red\", alpha.f = 0.25)\n    )\n  } else {\n    segments(\n      draws_posterior[i - 1, 1],\n      draws_posterior[i - 1, 2],\n      draws_posterior[i - 1, 1],\n      draws_posterior[i, 2],\n      col = adjustcolor(\"gray10\", alpha.f = 0.05),\n      lwd = 3\n    )\n    segments(\n      draws_posterior[i - 1, 1],\n      draws_posterior[i, 2],\n      draws_posterior[i, 1],\n      draws_posterior[i, 2],\n      col = adjustcolor(\"gray10\", alpha.f = 0.05),\n      lwd = 3\n    )\n    points(\n      draws_posterior[i, 1],\n      draws_posterior[i, 2],\n      pch = 21,\n      col = NA,\n      bg = adjustcolor(\"gray10\", alpha.f = 0.25)\n    )\n  }\n}", 
        opts = list(label = "\"joint-posterior\"", exercise = "TRUE", 
            exercise.lines = "30", fig.align = "\"center\"", 
            fig.width = "6", fig.height = "6", fig.align = "\"center\""), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "03-lec_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "center", fig.path = "03-lec_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6, fig.height = 6, fig.env = "figure", fig.cap = NULL, 
        fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 576, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "joint-posterior", exercise = TRUE, 
        exercise.lines = 30, code = c("# Apply function", "draws_posterior <-", 
        "  draw_from_posterior(", "    theta = 0,", "    omega = .1,", 
        "    alpha = 20,", "    beta = 200,", "    n_warmup = 100,", 
        "    n_draws = 1000,", "    data = gles$sup_afd,", "    keep_warmup = TRUE", 
        "  )", "", "# Save as matrix, transform precision to variance", 
        "draws_posterior <- simplify2array(draws_posterior)", 
        "draws_posterior[, 2] <- 1 / draws_posterior[, 2]", "", 
        "# Plot", "for (i in seq_len(nrow(draws_posterior))) {", 
        "  if (i == 1) {", "    plot(", "      draws_posterior[i, 1],", 
        "      draws_posterior[i, 2],", "      pch = 23,", "      xlim = range(draws_posterior[, 1]),", 
        "      ylim = range(draws_posterior[, 2]),", "      main = \"Exploration of the joint posterior\",", 
        "      xlab = expression(mu),", "      ylab = expression(sigma ^ 2),", 
        "      col = NA,", "      bg = adjustcolor(\"red\", alpha.f = 0.25)", 
        "    )", "  } else {", "    segments(", "      draws_posterior[i - 1, 1],", 
        "      draws_posterior[i - 1, 2],", "      draws_posterior[i - 1, 1],", 
        "      draws_posterior[i, 2],", "      col = adjustcolor(\"gray10\", alpha.f = 0.05),", 
        "      lwd = 3", "    )", "    segments(", "      draws_posterior[i - 1, 1],", 
        "      draws_posterior[i, 2],", "      draws_posterior[i, 1],", 
        "      draws_posterior[i, 2],", "      col = adjustcolor(\"gray10\", alpha.f = 0.05),", 
        "      lwd = 3", "    )", "    points(", "      draws_posterior[i, 1],", 
        "      draws_posterior[i, 2],", "      pch = 21,", "      col = NA,", 
        "      bg = adjustcolor(\"gray10\", alpha.f = 0.25)", 
        "    )", "  }", "}"), out.width.px = 576, out.height.px = 576, 
        params.src = "joint-posterior, exercise = TRUE, exercise.lines = 30, fig.align='center', fig.width = 6, fig.height=6, fig.align='center'", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>


<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-raftery-lewis-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-raftery-lewis-code-editor`)), session)
output$`tutorial-exercise-raftery-lewis-output` <- renderUI({
  `tutorial-exercise-raftery-lewis-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "raftery-lewis", global_setup = structure(c("## --- learnr ---", 
"if (\"learnr\" %in% (.packages()))", "  detach(package:learnr, unload = TRUE)", 
"library(learnr)", "knitr::opts_chunk$set(echo = FALSE)", "", 
"## ---- CRAN Packages ----", "## Save package names as a vector of strings", 
"pkgs <-  c(\"coda\", \"foreign\")", "", "## Install uninstalled packages", 
"lapply(pkgs[!(pkgs %in% installed.packages())], ", "       install.packages,", 
"       repos='http://cran.us.r-project.org')", "", "## Load all packages to library and adjust options", 
"lapply(pkgs, library, character.only = TRUE)", "", "## ---- GitHub Packages ----", 
"", "", "## ---- Global learnr Objects ----", "gles <- ", "  read.dta(\"https://github.com/denis-cohen/statmodeling/raw/main/data/gles.dta\")", 
"", "draw_from_prior <-", "  function(theta,", "           omega,", 
"           alpha,", "           beta,", "           n_draws,", 
"           seed = 20210329) {", "    # Set seed", "    set.seed(seed)", 
"    ", "    # Take draws", "    mu <- rnorm(n_draws, theta, 1 / sqrt(omega))", 
"    tau <- rgamma(n_draws, alpha, beta)", "    ", "    ## Return output", 
"    return(list(mu = mu,", "                tau = tau))", "  }", 
"", "draw_from_posterior <- function(theta,", "                                omega,", 
"                                alpha,", "                                beta,", 
"                                n_warmup,", "                                n_draws,", 
"                                data,", "                                seed = 20210329,", 
"                                keep_warmup = TRUE) {", "  # Set seed", 
"  set.seed(seed)", "", "  # Length of chain", "  len_chain <- n_warmup + n_draws", 
"  ", "  # Data characteristics", "  n_data <- length(data)  ", 
"  mean_data <- mean(data) ", "", "  # Initialize containers", 
"  mu <- rep(NA, len_chain)", "  tau <- rep(NA, len_chain)", 
"  ", "  # Run Gibbs sampler", "  for (i in seq_len(len_chain)) {", 
"    if (i == 1) {", "      ## Iteration 1: Initialize from prior", 
"      alpha_star <- alpha", "      beta_star <- beta", "    } else {", 
"      ## Iterations 2+: Update alpha and beta", "      alpha_star <- alpha + n_data / 2", 
"      beta_star <- beta + sum(((data - mu[i - 1]) ^ 2) / 2)", 
"    }", "    ", "    ## Sample tau", "    tau[i] <- rgamma(1, alpha_star, beta_star)", 
"    ", "    ## Update theta and omega", "    theta_star <-", 
"      (omega * theta + n_data * tau[i] * mean_data) /", "      (omega + n_data * tau[i])", 
"    omega_star <- omega + n_data * tau[i]", "    ", "    ## Sample mu", 
"    mu[i] <- rnorm(1, theta_star, 1 / sqrt(omega_star))", "  }", 
"  ", "  ## Conditionally discard warmup-draws", "  if (!keep_warmup) {", 
"    tau <- tau[(n_warmup + 1):len_chain]", "    mu <- mu[(n_warmup + 1):len_chain]", 
"  }", "  ", "  ## Return output", "  return(list(mu = mu,", 
"              tau = tau))", "}", "", "seeds <- sample(10001:99999, 4)", 
"draws_multiple_chains <- lapply(seeds,", "                                function(seed) {", 
"                                  as.mcmc(simplify2array(", 
"                                    draw_from_posterior(", "                                      theta = 0,", 
"                                      omega = .1,", "                                      alpha = 20,", 
"                                      beta = 200,", "                                      n_warmup = 200,", 
"                                      n_draws = 6147,", "                                      data = gles$sup_afd,", 
"                                      keep_warmup = FALSE,", 
"                                      seed = seed", "                                    )", 
"                                  ))", "                                })", 
"", "# Save as mcmc.list", "draws_multiple_chains <- as.mcmc.list(draws_multiple_chains)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "raftery-lewis", code = "# Example: Gill 2015, p. 503\n# If we want a 95% credible interval around the median \n# with reliability between 92.5% and 97.5%, we need:\nq <- 0.5    # quantile of interest\nr <- 0.0125 # margin of error\ns <- 0.95   # desired reliability\n\n## The recommend length for the pilot run:\nn <- ceiling((qnorm(.5 * (s + 1)) * sqrt(q * (1 - q)) / r) ^ 2)\n\n# Pilot run\ndraws_pilot <-\n  draw_from_posterior(\n    theta = 0,\n    omega = .1,\n    alpha = 20,\n    beta = 200,\n    n_warmup = 0,\n    n_draws = n,\n    data = gles$sup_afd,\n    keep_warmup = TRUE\n  )\n\n# Save as mcmc\ndraws_pilot <- as.mcmc(simplify2array(draws_pilot))\n\n# Diagnose\nraftery.diag(\n  draws_pilot,\n  q = q,\n  r = r,\n  s = s\n)", 
        opts = list(label = "\"raftery-lewis\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "03-lec_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "03-lec_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "raftery-lewis", exercise = TRUE, 
        code = c("# Example: Gill 2015, p. 503", "# If we want a 95% credible interval around the median ", 
        "# with reliability between 92.5% and 97.5%, we need:", 
        "q <- 0.5    # quantile of interest", "r <- 0.0125 # margin of error", 
        "s <- 0.95   # desired reliability", "", "## The recommend length for the pilot run:", 
        "n <- ceiling((qnorm(.5 * (s + 1)) * sqrt(q * (1 - q)) / r) ^ 2)", 
        "", "# Pilot run", "draws_pilot <-", "  draw_from_posterior(", 
        "    theta = 0,", "    omega = .1,", "    alpha = 20,", 
        "    beta = 200,", "    n_warmup = 0,", "    n_draws = n,", 
        "    data = gles$sup_afd,", "    keep_warmup = TRUE", 
        "  )", "", "# Save as mcmc", "draws_pilot <- as.mcmc(simplify2array(draws_pilot))", 
        "", "# Diagnose", "raftery.diag(", "  draws_pilot,", 
        "  q = q,", "  r = r,", "  s = s", ")"), out.width.px = 624, 
        out.height.px = 384, params.src = "raftery-lewis, exercise = TRUE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>


<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-other-diagnostics-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-other-diagnostics-code-editor`)), session)
output$`tutorial-exercise-other-diagnostics-output` <- renderUI({
  `tutorial-exercise-other-diagnostics-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "other-diagnostics", global_setup = structure(c("## --- learnr ---", 
"if (\"learnr\" %in% (.packages()))", "  detach(package:learnr, unload = TRUE)", 
"library(learnr)", "knitr::opts_chunk$set(echo = FALSE)", "", 
"## ---- CRAN Packages ----", "## Save package names as a vector of strings", 
"pkgs <-  c(\"coda\", \"foreign\")", "", "## Install uninstalled packages", 
"lapply(pkgs[!(pkgs %in% installed.packages())], ", "       install.packages,", 
"       repos='http://cran.us.r-project.org')", "", "## Load all packages to library and adjust options", 
"lapply(pkgs, library, character.only = TRUE)", "", "## ---- GitHub Packages ----", 
"", "", "## ---- Global learnr Objects ----", "gles <- ", "  read.dta(\"https://github.com/denis-cohen/statmodeling/raw/main/data/gles.dta\")", 
"", "draw_from_prior <-", "  function(theta,", "           omega,", 
"           alpha,", "           beta,", "           n_draws,", 
"           seed = 20210329) {", "    # Set seed", "    set.seed(seed)", 
"    ", "    # Take draws", "    mu <- rnorm(n_draws, theta, 1 / sqrt(omega))", 
"    tau <- rgamma(n_draws, alpha, beta)", "    ", "    ## Return output", 
"    return(list(mu = mu,", "                tau = tau))", "  }", 
"", "draw_from_posterior <- function(theta,", "                                omega,", 
"                                alpha,", "                                beta,", 
"                                n_warmup,", "                                n_draws,", 
"                                data,", "                                seed = 20210329,", 
"                                keep_warmup = TRUE) {", "  # Set seed", 
"  set.seed(seed)", "", "  # Length of chain", "  len_chain <- n_warmup + n_draws", 
"  ", "  # Data characteristics", "  n_data <- length(data)  ", 
"  mean_data <- mean(data) ", "", "  # Initialize containers", 
"  mu <- rep(NA, len_chain)", "  tau <- rep(NA, len_chain)", 
"  ", "  # Run Gibbs sampler", "  for (i in seq_len(len_chain)) {", 
"    if (i == 1) {", "      ## Iteration 1: Initialize from prior", 
"      alpha_star <- alpha", "      beta_star <- beta", "    } else {", 
"      ## Iterations 2+: Update alpha and beta", "      alpha_star <- alpha + n_data / 2", 
"      beta_star <- beta + sum(((data - mu[i - 1]) ^ 2) / 2)", 
"    }", "    ", "    ## Sample tau", "    tau[i] <- rgamma(1, alpha_star, beta_star)", 
"    ", "    ## Update theta and omega", "    theta_star <-", 
"      (omega * theta + n_data * tau[i] * mean_data) /", "      (omega + n_data * tau[i])", 
"    omega_star <- omega + n_data * tau[i]", "    ", "    ## Sample mu", 
"    mu[i] <- rnorm(1, theta_star, 1 / sqrt(omega_star))", "  }", 
"  ", "  ## Conditionally discard warmup-draws", "  if (!keep_warmup) {", 
"    tau <- tau[(n_warmup + 1):len_chain]", "    mu <- mu[(n_warmup + 1):len_chain]", 
"  }", "  ", "  ## Return output", "  return(list(mu = mu,", 
"              tau = tau))", "}", "", "seeds <- sample(10001:99999, 4)", 
"draws_multiple_chains <- lapply(seeds,", "                                function(seed) {", 
"                                  as.mcmc(simplify2array(", 
"                                    draw_from_posterior(", "                                      theta = 0,", 
"                                      omega = .1,", "                                      alpha = 20,", 
"                                      beta = 200,", "                                      n_warmup = 200,", 
"                                      n_draws = 6147,", "                                      data = gles$sup_afd,", 
"                                      keep_warmup = FALSE,", 
"                                      seed = seed", "                                    )", 
"                                  ))", "                                })", 
"", "# Save as mcmc.list", "draws_multiple_chains <- as.mcmc.list(draws_multiple_chains)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "other-diagnostics", code = "# Diagnose\ncoda::gelman.diag(draws_multiple_chains, autoburnin = FALSE)\ncoda::geweke.diag(draws_multiple_chains, frac1 = .1, frac2 = .5)  \ncoda::heidel.diag(draws_multiple_chains, pvalue = .1)             ", 
        opts = list(label = "\"other-diagnostics\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "03-lec_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "03-lec_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "other-diagnostics", exercise = TRUE, 
        code = c("# Diagnose", "coda::gelman.diag(draws_multiple_chains, autoburnin = FALSE)", 
        "coda::geweke.diag(draws_multiple_chains, frac1 = .1, frac2 = .5)  ", 
        "coda::heidel.diag(draws_multiple_chains, pvalue = .1)             "
        ), out.width.px = 624, out.height.px = 384, params.src = "other-diagnostics, exercise = TRUE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>


<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-trace-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-trace-code-editor`)), session)
output$`tutorial-exercise-trace-output` <- renderUI({
  `tutorial-exercise-trace-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "trace", global_setup = structure(c("## --- learnr ---", 
"if (\"learnr\" %in% (.packages()))", "  detach(package:learnr, unload = TRUE)", 
"library(learnr)", "knitr::opts_chunk$set(echo = FALSE)", "", 
"## ---- CRAN Packages ----", "## Save package names as a vector of strings", 
"pkgs <-  c(\"coda\", \"foreign\")", "", "## Install uninstalled packages", 
"lapply(pkgs[!(pkgs %in% installed.packages())], ", "       install.packages,", 
"       repos='http://cran.us.r-project.org')", "", "## Load all packages to library and adjust options", 
"lapply(pkgs, library, character.only = TRUE)", "", "## ---- GitHub Packages ----", 
"", "", "## ---- Global learnr Objects ----", "gles <- ", "  read.dta(\"https://github.com/denis-cohen/statmodeling/raw/main/data/gles.dta\")", 
"", "draw_from_prior <-", "  function(theta,", "           omega,", 
"           alpha,", "           beta,", "           n_draws,", 
"           seed = 20210329) {", "    # Set seed", "    set.seed(seed)", 
"    ", "    # Take draws", "    mu <- rnorm(n_draws, theta, 1 / sqrt(omega))", 
"    tau <- rgamma(n_draws, alpha, beta)", "    ", "    ## Return output", 
"    return(list(mu = mu,", "                tau = tau))", "  }", 
"", "draw_from_posterior <- function(theta,", "                                omega,", 
"                                alpha,", "                                beta,", 
"                                n_warmup,", "                                n_draws,", 
"                                data,", "                                seed = 20210329,", 
"                                keep_warmup = TRUE) {", "  # Set seed", 
"  set.seed(seed)", "", "  # Length of chain", "  len_chain <- n_warmup + n_draws", 
"  ", "  # Data characteristics", "  n_data <- length(data)  ", 
"  mean_data <- mean(data) ", "", "  # Initialize containers", 
"  mu <- rep(NA, len_chain)", "  tau <- rep(NA, len_chain)", 
"  ", "  # Run Gibbs sampler", "  for (i in seq_len(len_chain)) {", 
"    if (i == 1) {", "      ## Iteration 1: Initialize from prior", 
"      alpha_star <- alpha", "      beta_star <- beta", "    } else {", 
"      ## Iterations 2+: Update alpha and beta", "      alpha_star <- alpha + n_data / 2", 
"      beta_star <- beta + sum(((data - mu[i - 1]) ^ 2) / 2)", 
"    }", "    ", "    ## Sample tau", "    tau[i] <- rgamma(1, alpha_star, beta_star)", 
"    ", "    ## Update theta and omega", "    theta_star <-", 
"      (omega * theta + n_data * tau[i] * mean_data) /", "      (omega + n_data * tau[i])", 
"    omega_star <- omega + n_data * tau[i]", "    ", "    ## Sample mu", 
"    mu[i] <- rnorm(1, theta_star, 1 / sqrt(omega_star))", "  }", 
"  ", "  ## Conditionally discard warmup-draws", "  if (!keep_warmup) {", 
"    tau <- tau[(n_warmup + 1):len_chain]", "    mu <- mu[(n_warmup + 1):len_chain]", 
"  }", "  ", "  ## Return output", "  return(list(mu = mu,", 
"              tau = tau))", "}", "", "seeds <- sample(10001:99999, 4)", 
"draws_multiple_chains <- lapply(seeds,", "                                function(seed) {", 
"                                  as.mcmc(simplify2array(", 
"                                    draw_from_posterior(", "                                      theta = 0,", 
"                                      omega = .1,", "                                      alpha = 20,", 
"                                      beta = 200,", "                                      n_warmup = 200,", 
"                                      n_draws = 6147,", "                                      data = gles$sup_afd,", 
"                                      keep_warmup = FALSE,", 
"                                      seed = seed", "                                    )", 
"                                  ))", "                                })", 
"", "# Save as mcmc.list", "draws_multiple_chains <- as.mcmc.list(draws_multiple_chains)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "trace", code = "par(mfrow = c(1, 2))\ncoda::traceplot(draws_multiple_chains, smooth = TRUE)", 
        opts = list(label = "\"trace\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "03-lec_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "03-lec_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "trace", exercise = TRUE, code = c("par(mfrow = c(1, 2))", 
        "coda::traceplot(draws_multiple_chains, smooth = TRUE)"
        ), out.width.px = 624, out.height.px = 384, params.src = "trace, exercise = TRUE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>


<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-autocorr-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-autocorr-code-editor`)), session)
output$`tutorial-exercise-autocorr-output` <- renderUI({
  `tutorial-exercise-autocorr-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "autocorr", global_setup = structure(c("## --- learnr ---", 
"if (\"learnr\" %in% (.packages()))", "  detach(package:learnr, unload = TRUE)", 
"library(learnr)", "knitr::opts_chunk$set(echo = FALSE)", "", 
"## ---- CRAN Packages ----", "## Save package names as a vector of strings", 
"pkgs <-  c(\"coda\", \"foreign\")", "", "## Install uninstalled packages", 
"lapply(pkgs[!(pkgs %in% installed.packages())], ", "       install.packages,", 
"       repos='http://cran.us.r-project.org')", "", "## Load all packages to library and adjust options", 
"lapply(pkgs, library, character.only = TRUE)", "", "## ---- GitHub Packages ----", 
"", "", "## ---- Global learnr Objects ----", "gles <- ", "  read.dta(\"https://github.com/denis-cohen/statmodeling/raw/main/data/gles.dta\")", 
"", "draw_from_prior <-", "  function(theta,", "           omega,", 
"           alpha,", "           beta,", "           n_draws,", 
"           seed = 20210329) {", "    # Set seed", "    set.seed(seed)", 
"    ", "    # Take draws", "    mu <- rnorm(n_draws, theta, 1 / sqrt(omega))", 
"    tau <- rgamma(n_draws, alpha, beta)", "    ", "    ## Return output", 
"    return(list(mu = mu,", "                tau = tau))", "  }", 
"", "draw_from_posterior <- function(theta,", "                                omega,", 
"                                alpha,", "                                beta,", 
"                                n_warmup,", "                                n_draws,", 
"                                data,", "                                seed = 20210329,", 
"                                keep_warmup = TRUE) {", "  # Set seed", 
"  set.seed(seed)", "", "  # Length of chain", "  len_chain <- n_warmup + n_draws", 
"  ", "  # Data characteristics", "  n_data <- length(data)  ", 
"  mean_data <- mean(data) ", "", "  # Initialize containers", 
"  mu <- rep(NA, len_chain)", "  tau <- rep(NA, len_chain)", 
"  ", "  # Run Gibbs sampler", "  for (i in seq_len(len_chain)) {", 
"    if (i == 1) {", "      ## Iteration 1: Initialize from prior", 
"      alpha_star <- alpha", "      beta_star <- beta", "    } else {", 
"      ## Iterations 2+: Update alpha and beta", "      alpha_star <- alpha + n_data / 2", 
"      beta_star <- beta + sum(((data - mu[i - 1]) ^ 2) / 2)", 
"    }", "    ", "    ## Sample tau", "    tau[i] <- rgamma(1, alpha_star, beta_star)", 
"    ", "    ## Update theta and omega", "    theta_star <-", 
"      (omega * theta + n_data * tau[i] * mean_data) /", "      (omega + n_data * tau[i])", 
"    omega_star <- omega + n_data * tau[i]", "    ", "    ## Sample mu", 
"    mu[i] <- rnorm(1, theta_star, 1 / sqrt(omega_star))", "  }", 
"  ", "  ## Conditionally discard warmup-draws", "  if (!keep_warmup) {", 
"    tau <- tau[(n_warmup + 1):len_chain]", "    mu <- mu[(n_warmup + 1):len_chain]", 
"  }", "  ", "  ## Return output", "  return(list(mu = mu,", 
"              tau = tau))", "}", "", "seeds <- sample(10001:99999, 4)", 
"draws_multiple_chains <- lapply(seeds,", "                                function(seed) {", 
"                                  as.mcmc(simplify2array(", 
"                                    draw_from_posterior(", "                                      theta = 0,", 
"                                      omega = .1,", "                                      alpha = 20,", 
"                                      beta = 200,", "                                      n_warmup = 200,", 
"                                      n_draws = 6147,", "                                      data = gles$sup_afd,", 
"                                      keep_warmup = FALSE,", 
"                                      seed = seed", "                                    )", 
"                                  ))", "                                })", 
"", "# Save as mcmc.list", "draws_multiple_chains <- as.mcmc.list(draws_multiple_chains)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "autocorr", code = "coda::autocorr.plot(draws_multiple_chains)", 
        opts = list(label = "\"autocorr\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "03-lec_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "03-lec_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, label = "autocorr", exercise = TRUE, 
        code = "coda::autocorr.plot(draws_multiple_chains)", 
        out.width.px = 624, out.height.px = 384, params.src = "autocorr, exercise = TRUE", 
        fig.num = 0, exercise.df_print = "paged", exercise.checker = "NULL"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
</li>
</ul>
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["header-attrs"]},{"type":"character","attributes":{},"value":["2.17"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pandoc"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["header-attrs.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/cerulean.min.css"]},{"type":"character","attributes":{},"value":["<style>h1 {font-size: 34px;}\n       h1.title {font-size: 38px;}\n       h2 {font-size: 30px;}\n       h3 {font-size: 24px;}\n       h4 {font-size: 18px;}\n       h5 {font-size: 16px;}\n       h6 {font-size: 12px;}\n       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}\n       pre:not([class]) { background-color: white }<\/style>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["pagedtable"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pagedtable-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/pagedtable.js"]},{"type":"character","attributes":{},"value":["css/pagedtable.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["textmate.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.11.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["i18n"]},{"type":"character","attributes":{},"value":["21.6.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/i18n"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["i18next.min.js","tutorial-i18n-init.js"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["<script id=\"i18n-cstm-trns\" type=\"application/json\">{\"language\":\"en\",\"resources\":{\"en\":{\"translation\":{\"button\":{\"runcode\":\"Run Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Hint\",\"hint_plural\":\"Hints\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Next Hint\",\"hintprev\":\"Previous Hint\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copy to Clipboard\",\"startover\":\"Start Over\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continue\",\"submitanswer\":\"Submit Answer\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Previous Topic\",\"nexttopic\":\"Next Topic\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Try Again\"},\"text\":{\"startover\":\"Start Over\",\"areyousure\":\"Are you sure you want to start over? (all exercise progress will be reset)\",\"youmustcomplete\":\"You must complete the\",\"exercise\":\"exercise\",\"exercise_plural\":\"exercises\",\"inthissection\":\"in this section before continuing.\",\"code\":\"Code\",\"enginecap\":\"{{engine}} $t(text.code)\",\"quiz\":\"Quiz\",\"blank\":\"blank\",\"blank_plural\":\"blanks\",\"exercisecontainsblank\":\"This exercise contains {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Please replace {{blank}} with valid code.\",\"unparsable\":\"It looks like this might not be valid R code. R cannot determine how to turn your text into a complete command. You may have forgotten to fill in a blank, to remove an underscore, to include a comma between arguments, or to close an opening <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> or <code>{<\\/code> with a matching <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> or <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>It looks like your R code contains specially formatted quotation marks or &quot;curly&quot; quotes (<code>{{character}}<\\/code>) around character strings, making your code invalid. R requires character values to be contained in straight quotation marks (<code>&quot;<\\/code> or <code>'<\\/code>).<\\/p> {{code}} <p>Don't worry, this is a common source of errors when you copy code from another app that applies its own formatting to text. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. Try deleting the special character from your code and retyping it manually.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"and\":\"and\",\"or\":\"or\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"fr\":{\"translation\":{\"button\":{\"runcode\":\"Lancer le Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Indication\",\"hint_plural\":\"Indications\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Indication Suivante\",\"hintprev\":\"Indication Précédente\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copier dans le Presse-papier\",\"startover\":\"Recommencer\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuer\",\"submitanswer\":\"Soumettre\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Chapitre Précédent\",\"nexttopic\":\"Chapitre Suivant\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Réessayer\"},\"text\":{\"startover\":\"Recommencer\",\"areyousure\":\"Êtes-vous certains de vouloir recommencer? (La progression sera remise à zéro)\",\"youmustcomplete\":\"Vous devez d'abord compléter\",\"exercise\":\"l'exercice\",\"exercise_plural\":\"des exercices\",\"inthissection\":\"de cette section avec de continuer.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"et\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"es\":{\"translation\":{\"button\":{\"runcode\":\"Ejecutar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Pista\",\"hint_plural\":\"Pistas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Siguiente pista\",\"hintprev\":\"Pista anterior\",\"solution\":\"Solución\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar al portapapeles\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar respuesta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tema anterior\",\"nexttopic\":\"Tema siguiente\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Volver a intentar\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"¿De verdad quieres empezar de nuevo? (todo el progreso del ejercicio se perderá)\",\"youmustcomplete\":\"Debes completar\",\"exercise\":\"el ejercicio\",\"exercise_plural\":\"los ejercicios\",\"inthissection\":\"en esta sección antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Cuestionario\",\"and\":\"y\",\"or\":\"o\",\"oxfordcomma\":\"\"}}},\"pt\":{\"translation\":{\"button\":{\"runcode\":\"Executar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Dica\",\"hint_plural\":\"Dicas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Próxima dica\",\"hintprev\":\"Dica anterior\",\"solution\":\"Solução\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar para a área de transferência\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar resposta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tópico anterior\",\"nexttopic\":\"Próximo tópico\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tentar novamente\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"Tem certeza que deseja começar novamente? (todo o progresso feito será perdido)\",\"youmustcomplete\":\"Você deve completar\",\"exercise\":\"o exercício\",\"exercise_plural\":\"os exercícios\",\"inthissection\":\"nesta seção antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"e\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"tr\":{\"translation\":{\"button\":{\"runcode\":\"Çalistirma Kodu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Ipucu\",\"hint_plural\":\"Ipuçlari\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Sonraki Ipucu\",\"hintprev\":\"Önceki Ipucu\",\"solution\":\"Çözüm\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Pano'ya Kopyala\",\"startover\":\"Bastan Baslamak\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Devam et\",\"submitanswer\":\"Cevabi onayla\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Önceki Konu\",\"nexttopic\":\"Sonraki Konu\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tekrar Deneyin\"},\"text\":{\"startover\":\"Bastan Baslamak\",\"areyousure\":\"Bastan baslamak istediginizden emin misiniz? (tüm egzersiz ilerlemesi kaybolacak)\",\"youmustcomplete\":\"Tamamlamalisin\",\"exercise\":\"egzersiz\",\"exercise_plural\":\"egzersizler\",\"inthissection\":\"devam etmeden önce bu bölümde\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Sinav\",\"oxfordcomma\":\"\"}}},\"emo\":{\"translation\":{\"button\":{\"runcode\":\"<U+0001F3C3>\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"<U+0001F4A1>\",\"hint_plural\":\"$t(button.hint)\",\"hinttitle\":\"$t(button.hint)\",\"solution\":\"<U+0001F3AF>\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"<U+0001F4CB>\",\"startover\":\"<U+23EE>\",\"startovertitle\":\"Start Over\",\"continue\":\"<U+2705>\",\"submitanswer\":\"<U+0001F197>\",\"submitanswertitle\":\"Submit Answer\",\"previoustopic\":\"<U+2B05>\",\"nexttopic\":\"<U+27A1>\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"<U+0001F501>\"},\"text\":{\"startover\":\"<U+23EE>\",\"areyousure\":\"<U+0001F914>\",\"youmustcomplete\":\"<U+26A0><U+FE0F> <U+0001F449> <U+0001F9D1><U+200D><U+0001F4BB>\",\"exercise\":\"\",\"exercise_plural\":\"\",\"inthissection\":\"\",\"code\":\"<U+0001F4BB>\",\"enginecap\":\"$t(text.code) {{engine}}\",\"oxfordcomma\":\"\"}}},\"eu\":{\"translation\":{\"button\":{\"runcode\":\"Kodea egikaritu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Laguntza\",\"hint_plural\":\"Laguntza\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Aurreko laguntza\",\"hintprev\":\"Hurrengo laguntza\",\"solution\":\"Ebazpena\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Arbelean kopiatu\",\"startover\":\"Berrabiarazi\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Jarraitu\",\"submitanswer\":\"Erantzuna bidali\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Aurreko atala\",\"nexttopic\":\"Hurrengo atala\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Berriro saiatu\"},\"text\":{\"startover\":\"Berrabiarazi\",\"areyousure\":\"Berriro hasi nahi duzu? (egindako lana galdu egingo da)\",\"youmustcomplete\":\"Aurrera egin baino lehen atal honetako\",\"exercise\":\"ariketa egin behar duzu.\",\"exercise_plural\":\"ariketak egin behar dituzu.\",\"inthissection\":\"\",\"code\":\"Kodea\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Galdetegia\",\"oxfordcomma\":\"\"}}},\"de\":{\"translation\":{\"button\":{\"runcode\":\"Code ausführen\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Tipp\",\"hint_plural\":\"Tipps\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Nächster Tipp\",\"hintprev\":\"Vorheriger Tipp\",\"solution\":\"Lösung\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"In die Zwischenablage kopieren\",\"startover\":\"Neustart\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Weiter\",\"submitanswer\":\"Antwort einreichen\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Vorheriges Kapitel\",\"nexttopic\":\"Nächstes Kapitel\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Nochmal versuchen\"},\"text\":{\"startover\":\"Neustart\",\"areyousure\":\"Bist du sicher, dass du neustarten willst? (der gesamte Lernfortschritt wird gelöscht)\",\"youmustcomplete\":\"Vervollstädinge\",\"exercise\":\"die Übung\",\"exercise_plural\":\"die Übungen\",\"inthissection\":\"in diesem Kapitel, bevor du fortfährst.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"Lücke\",\"blank_plural\":\"Lücken\",\"pleasereplaceblank\":\"Bitte ersetze {{blank}} mit gültigem Code.\",\"unparsable\":\"Dies scheint kein gültiger R Code zu sein. R kann deinen Text nicht in einen gültigen Befehl übersetzen. Du hast vielleicht vergessen, die Lücke zu füllen, einen Unterstrich zu entfernen, ein Komma zwischen Argumente zu setzen oder ein eröffnendes <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> oder <code>{<\\/code> mit einem zugehörigen <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> oder <code>}<\\/code> zu schließen.\\n\",\"and\":\"und\",\"or\":\"oder\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"ko\":{\"translation\":{\"button\":{\"runcode\":\"<U+CF54><U+B4DC> <U+C2E4><U+D589>\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"<U+D78C><U+D2B8>\",\"hint_plural\":\"<U+D78C><U+D2B8><U+B4E4>\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"<U+B2E4><U+C74C> <U+D78C><U+D2B8>\",\"hintprev\":\"<U+C774><U+C804> <U+D78C><U+D2B8>\",\"solution\":\"<U+C194><U+B8E8><U+C158>\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"<U+D074><U+B9BD><U+BCF4><U+B4DC><U+C5D0> <U+BCF5><U+C0AC>\",\"startover\":\"<U+C7AC><U+D559><U+C2B5>\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"<U+B2E4><U+C74C> <U+D559><U+C2B5><U+C73C><U+B85C>\",\"submitanswer\":\"<U+C815><U+B2F5> <U+C81C><U+CD9C>\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"<U+C774><U+C804> <U+D1A0><U+D53D>\",\"nexttopic\":\"<U+B2E4><U+C74C> <U+D1A0><U+D53D>\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"<U+C7AC><U+C2DC><U+B3C4>\"},\"text\":{\"startover\":\"<U+C7AC><U+D559><U+C2B5>\",\"areyousure\":\"<U+B2E4><U+C2DC> <U+C2DC><U+C791> <U+D558><U+C2DC><U+ACA0><U+C2B5><U+B2C8><U+AE4C>? (<U+BAA8><U+B4E0> <U+C608><U+C81C><U+C758> <U+C9C4><U+D589> <U+C815><U+BCF4><U+AC00> <U+C7AC><U+C124><U+C815><U+B429><U+B2C8><U+B2E4>)\",\"youmustcomplete\":\"<U+B2F9><U+C2E0><U+C740> <U+C644><U+B8CC><U+D574><U+C57C> <U+D569><U+B2C8><U+B2E4>\",\"exercise\":\"<U+C5F0><U+C2B5><U+BB38><U+C81C>\",\"exercise_plural\":\"<U+C5F0><U+C2B5><U+BB38><U+C81C><U+B4E4>\",\"inthissection\":\"<U+C774> <U+C139><U+C158><U+C744> <U+C2E4><U+D589><U+D558><U+AE30> <U+C804><U+C5D0>\",\"code\":\"<U+CF54><U+B4DC>\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"<U+D034><U+C988>\",\"blank\":\"<U+ACF5><U+BC31>\",\"blank_plural\":\"<U+ACF5><U+BC31><U+B4E4>\",\"exercisecontainsblank\":\"<U+C774> <U+C5F0><U+C2B5><U+BB38><U+C81C><U+C5D0><U+B294> {{count}}<U+AC1C><U+C758> $t(text.blank)<U+C774> <U+D3EC><U+D568><U+B418><U+C5B4> <U+C788><U+C2B5><U+B2C8><U+B2E4>.\",\"pleasereplaceblank\":\"{{blank}}<U+B97C> <U+C720><U+D6A8><U+D55C> <U+CF54><U+B4DC><U+B85C> <U+BC14><U+AFB8><U+C2ED><U+C2DC><U+C624>.\",\"unparsable\":\"<U+C774><U+AC83><U+C740> <U+C720><U+D6A8><U+D55C> R <U+CF54><U+B4DC><U+AC00> <U+C544><U+B2D0> <U+C218> <U+C788><U+C2B5><U+B2C8><U+B2E4>. R<U+C740> <U+D14D><U+C2A4><U+D2B8><U+B97C> <U+C644><U+C804><U+D55C> <U+BA85><U+B839><U+C73C><U+B85C> <U+BCC0><U+D658><U+D558><U+B294> <U+BC29><U+BC95><U+C744> <U+ACB0><U+C815><U+D560> <U+C218> <U+C5C6><U+C2B5><U+B2C8><U+B2E4>. <U+B2F9><U+C2E0><U+C740> <U+ACF5><U+BC31><U+C774><U+B098> <U+BC11><U+C904><U+C744> <U+B300><U+CCB4><U+D558><U+C5EC> <U+CC44><U+C6B0><U+AE30>, <U+C778><U+C218><U+B97C> <U+CEF4><U+B9C8><U+B85C> <U+AD6C><U+BD84><U+D558><U+AE30>, <U+B610><U+B294> <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> , <code>{<\\/code><U+B85C> <U+C2DC><U+C791><U+D558><U+B294> <U+AD6C><U+BB38><U+C744> <U+B2EB><U+B294> <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>, <code>}<\\/code><U+C744> <U+C78A><U+C5C8><U+C744> <U+C218><U+B3C4> <U+C788><U+C2B5><U+B2C8><U+B2E4>.\\n\",\"and\":\"<U+ADF8><U+B9AC><U+ACE0>\",\"or\":\"<U+D639><U+C740>\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}},\"zh\":{\"translation\":{\"button\":{\"runcode\":\"<U+8FD0><U+884C><U+4EE3><U+7801>\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"<U+63D0><U+793A>\",\"hint_plural\":\"<U+63D0><U+793A>\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"<U+4E0B><U+4E00><U+4E2A><U+63D0><U+793A>\",\"hintprev\":\"<U+4E0A><U+4E00><U+4E2A><U+63D0><U+793A>\",\"solution\":\"<U+7B54><U+6848>\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"<U+590D><U+5236><U+5230><U+526A><U+5207><U+677F>\",\"startover\":\"<U+91CD><U+65B0><U+5F00><U+59CB>\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"<U+7EE7><U+7EED>\",\"submitanswer\":\"<U+63D0><U+4EA4><U+7B54><U+6848>\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"<U+4E0A><U+4E00><U+4E13><U+9898>\",\"nexttopic\":\"<U+4E0B><U+4E00><U+4E13><U+9898>\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"<U+518D><U+8BD5><U+4E00><U+6B21>\"},\"text\":{\"startover\":\"<U+91CD><U+7F6E>\",\"areyousure\":\"<U+4F60><U+786E><U+5B9A><U+8981><U+91CD><U+65B0><U+5F00><U+59CB><U+5417>? (<U+6240><U+6709><U+5F53><U+524D><U+8FDB><U+5EA6><U+5C06><U+88AB><U+91CD><U+7F6E>)\",\"youmustcomplete\":\"<U+4F60><U+5FC5><U+987B><U+5B8C><U+6210>\",\"exercise\":\"<U+7EC3><U+4E60>\",\"exercise_plural\":\"<U+7EC3><U+4E60>\",\"inthissection\":\"<U+5728><U+8FDB><U+884C><U+672C><U+8282><U+4E4B><U+524D>\",\"code\":\"<U+4EE3><U+7801>\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"<U+6D4B><U+8BD5>\",\"blank\":\"<U+7A7A>\",\"blank_plural\":\"<U+7A7A>\",\"exercisecontainsblank\":\"<U+672C><U+7EC3><U+4E60><U+5305><U+542B>{{count}}<U+4E2A>$t(text.blank)\",\"pleasereplaceblank\":\"<U+8BF7><U+5728>{{blank}}<U+5185><U+586B><U+5199><U+6070><U+5F53><U+7684><U+4EE3><U+7801>\",\"unparsable\":\"<U+8FD9><U+4F3C><U+4E4E><U+4E0D><U+662F><U+6709><U+6548><U+7684>R<U+4EE3><U+7801><U+3002> R<U+4E0D><U+77E5><U+9053><U+5982><U+4F55><U+5C06><U+60A8><U+7684><U+6587><U+672C><U+8F6C><U+6362><U+4E3A><U+5B8C><U+6574><U+7684><U+547D><U+4EE4><U+3002> <U+60A8><U+662F><U+5426><U+5FD8><U+4E86><U+586B><U+7A7A>,<U+5FD8><U+4E86><U+5220><U+9664><U+4E0B><U+5212><U+7EBF>,<U+5FD8><U+4E86><U+5728><U+53C2><U+6570><U+4E4B><U+95F4><U+5305><U+542B><U+9017><U+53F7>,<U+6216><U+8005><U+662F><U+5FD8><U+4E86><U+7528><code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>,<code>}<\\/code><U+6765><U+5C01><U+95ED><code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code><U+3002> or <code>{<\\/code><U+3002>\\n\",\"unparsablequotes\":\"<p><U+60A8><U+7684>R<U+4EE3><U+7801><U+4E2D><U+4F3C><U+4E4E><U+542B><U+6709><U+7279><U+6B8A><U+683C><U+5F0F><U+7684><U+5F15><U+53F7>,<U+6216><U+8005><U+5F2F><U+5F15><U+53F7>(<code>{{character}}<\\/code>) <U+5728><U+5B57><U+7B26><U+4E32><U+524D><U+540E>,<U+5728>R<U+4E2D><U+5B57><U+7B26><U+4E32><U+5E94><U+8BE5><U+88AB><U+76F4><U+5F15><U+53F7>(<code>&quot;<\\/code> <U+6216><U+8005> <code>'<\\/code>)<U+5305><U+88F9><U+3002><\\/p> {{code}} <p><U+522B><U+62C5><U+5FC3>,<U+8BE5><U+9519><U+8BEF><U+7ECF><U+5E38><U+5728><U+590D><U+5236><U+7C98><U+8D34><U+5305><U+542B><U+683C><U+5F0F><U+7684><U+4EE3><U+7801><U+65F6><U+9047><U+5230>, <U+60A8><U+53EF><U+4EE5><U+5C1D><U+8BD5><U+5C06><U+8BE5><U+884C><U+4E2D><U+7684><U+4EE3><U+7801><U+66FF><U+6362><U+4E3A><U+4EE5><U+4E0B><U+4EE3><U+7801>,<U+4E5F><U+8BB8><U+8FD8><U+6709><U+5176><U+4ED6><U+5730><U+65B9><U+9700><U+8981><U+4FEE><U+6539><U+3002><\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p><U+60A8><U+7684><U+4EE3><U+7801><U+4E2D><U+4F3C><U+4E4E><U+5305><U+542B><U+6709><U+5F02><U+5E38><U+5B57><U+7B26>(<code>{{character}}<\\/code>),<U+5BFC><U+81F4><U+4EE3><U+7801><U+65E0><U+6548><U+3002><\\/p> {{code}} <p><U+6709><U+65F6><U+5019><U+4F60><U+7684><U+4EE3><U+7801><U+53EF><U+80FD><U+542B><U+6709><U+770B><U+4F3C><U+6B63><U+5E38><U+5B57><U+7B26><U+7684><U+7279><U+6B8A><U+5B57><U+7B26>,<U+7279><U+522B><U+662F><U+5F53><U+4F60><U+590D><U+5236><U+7C98><U+8D34><U+5176><U+4ED6><U+6765><U+6E90><U+4EE3><U+7801><U+7684><U+65F6><U+5019><U+3002> <U+8BF7><U+8BD5><U+7740><U+5220><U+9664><U+8FD9><U+4E9B><U+7279><U+6B8A><U+5B57><U+7B26>,<U+91CD><U+65B0><U+8F93><U+5165><\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p><U+60A8><U+7684><U+4EE3><U+7801><U+4E2D><U+4F3C><U+4E4E><U+5305><U+542B><U+6709><U+5F02><U+5E38><U+5B57><U+7B26>(<code>{{character}}<\\/code>),<U+5BFC><U+81F4><U+4EE3><U+7801><U+65E0><U+6548><U+3002><\\/p> {{code}} <p><U+6709><U+65F6><U+5019><U+4F60><U+7684><U+4EE3><U+7801><U+53EF><U+80FD><U+542B><U+6709><U+770B><U+4F3C><U+6B63><U+5E38><U+5B57><U+7B26><U+7684><U+7279><U+6B8A><U+5B57><U+7B26>,<U+7279><U+522B><U+662F><U+5F53><U+4F60><U+590D><U+5236><U+7C98><U+8D34><U+5176><U+4ED6><U+6765><U+6E90><U+4EE3><U+7801><U+7684><U+65F6><U+5019><U+3002> <U+8BF7><U+8BD5><U+7740><U+5220><U+9664><U+8FD9><U+4E9B><U+7279><U+6B8A><U+5B57><U+7B26>,<U+91CD><U+65B0><U+8F93><U+5165><\\/p>\\n\",\"and\":\"<U+4E14>\",\"or\":\"<U+6216>\",\"listcomma\":\",\",\"oxfordcomma\":\",\"}}},\"pl\":{\"translation\":{\"button\":{\"runcode\":\"Uruchom kod\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Podpowiedz\",\"hint_plural\":\"Podpowiedzi\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Nastepna podpowiedz\",\"hintprev\":\"Poprzednia podpowiedz\",\"solution\":\"Rozwiazanie\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Kopiuj do schowka\",\"startover\":\"Zacznij od poczatku\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Kontynuuj\",\"submitanswer\":\"Wyslij\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Poprzednia sekcja\",\"nexttopic\":\"Nastepna sekcja\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Spróbuj ponownie\"},\"text\":{\"startover\":\"Zacznij od poczatku\",\"areyousure\":\"Czy na pewno chcesz zaczac od poczatku? (caly postep w zadaniu zostanie utracony)\",\"youmustcomplete\":\"Musisz ukonczyc\",\"exercise\":\"cwiczenie\",\"exercise_plural\":\"cwiczenia\",\"inthissection\":\"w tej sekcji przed kontynuowaniem\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"luka\",\"blank_plural\":\"luk(i)\",\"exercisecontainsblank\":\"To cwiczenie zawiera {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Prosze uzupelnic {{blank}} prawidlowym kodem.\",\"unparsable\":\"Wyglada na to, ze moze to nie byc prawidlowy kod R. R nie jest w stanie przetworzyc Twojego tekstu na polecenie. Mogles(-as) zapomniec wypelnic luki, usunac podkreslnik, umiescic przecinka miedzy argumentami, lub zamknac znak <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> lub <code>{<\\/code> odpowiadajacym <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> lub <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>Wyglada na to, ze Twój kod zawiera szczególnie sformatowane cudzyslowy lub cudzyslowy typograficzne (<code>{{character}}<\\/code>) przy ciagach znaków, co sprawia, ze kod jest niepoprawny. R wymaga cudzyslowów prostych (<code>&quot;<\\/code> albo <code>'<\\/code>).<\\/p> {{code}} <p>Nie martw sie, to powszechne zródlo bledów, gdy kopiuje sie kod z innego programu, który sam formatuje teskt. Mozesz spróbowac zastapic swój kod nastepujacym kodem. Moga byc tez inne miejsca, które wymagaja poprawienia.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>Wyglada na to, ze Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, ze kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod moze zawierac znak specjalny, który wyglada jak zwykly znak, zwlaszcza jesli kopiujesz kod z innego programu. Spróbuj usunac znak specjalny i wpisac do ponownie recznie.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>Wyglada na to, ze Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, ze kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod moze zawierac znak specjalny, który wyglada jak zwykly znak, zwlaszcza jesli kopiujesz kod z innego programu. Mozesz spróbowac zastapic swój kod nastepujacym kodem. Moga byc tez inne miejsca, które wymagaja poprawienia.<\\/p> {{suggestion}}\\n\",\"and\":\"i\",\"or\":\"lub\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}}}}<\/script>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-format"]},{"type":"character","attributes":{},"value":["0.11.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmarkdown/templates/tutorial/resources"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-format.js"]},{"type":"character","attributes":{},"value":["tutorial-format.css","rstudio-theme.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["navigation"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/navigation-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tabsets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["default.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["font-awesome"]},{"type":"character","attributes":{},"value":["5.1.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/fontawesome"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/all.css","css/v4-shims.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootbox"]},{"type":"character","attributes":{},"value":["5.5.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/bootbox"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["bootbox.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["idb-keyvalue"]},{"type":"character","attributes":{},"value":["3.2.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/idb-keyval"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["idb-keyval-iife-compat.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.11.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.10.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.11.1"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]}},"value":[{"type":"character","attributes":{},"value":["backports","base","bslib","cachem","checkmate","cli","coda","compiler","curl","datasets","digest","ellipsis","evaluate","fastmap","foreign","graphics","grDevices","grid","highr","htmltools","htmlwidgets","httpuv","jquerylib","jsonlite","knitr","later","lattice","learnr","lifecycle","magrittr","markdown","methods","mime","promises","R6","Rcpp","rlang","rmarkdown","rprojroot","rstudioapi","sass","shiny","stats","stringi","stringr","tools","utils","withr","xfun","xtable","yaml"]},{"type":"character","attributes":{},"value":["1.4.1","4.2.1","0.4.1","1.0.6","2.1.0","3.4.0","0.19-4","4.2.1","4.3.2","4.2.1","0.6.29","0.3.2","0.18","1.1.0","0.8-82","4.2.1","4.2.1","4.2.1","0.9","0.5.3","1.5.4","1.6.6","0.1.4","1.8.0","1.40","1.3.0","0.20-45","0.11.1","1.0.3","2.0.3","1.3","4.2.1","0.12","1.2.0.1","2.5.1","1.0.9","1.0.6","2.17","2.0.3","0.14","0.4.2","1.7.3","4.2.1","1.7.8","1.4.1","4.2.1","4.2.1","2.5.0","0.33","1.8-4","2.3.5"]}]}]}
</script>
<!--/html_preserve-->
</div>
</div>

</article> <!-- topics -->

<div class="topicsContainer">
<div class="topicsPositioner">
<div class="band">
<div class="bandContent topicsListContainer">

<!-- begin doc-metadata -->
<div id="doc-metadata">
<h1 class="title toc-ignore" style="display:none;">Lecture: Bayesian
Fundamentals</h1>
</div>
<!-- end doc-metadata -->

</div> <!-- bandContent.topicsListContainer -->
</div> <!-- band -->
</div> <!-- topicsPositioner -->
</div> <!-- topicsContainer -->


</main> <!-- bandContent page -->
</div> <!-- pageContent band -->



<!-- Build Tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("section-TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<script>
// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>


</body>

</html>
